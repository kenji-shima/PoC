var mapboxsearch = (() => {
  var js = Object.create; var Rt = Object.defineProperty, $s = Object.defineProperties, Us = Object.getOwnPropertyDescriptor, zs = Object.getOwnPropertyDescriptors, Gs = Object.getOwnPropertyNames, mi = Object.getOwnPropertySymbols, Vs = Object.getPrototypeOf, on = Object.prototype.hasOwnProperty, Zn = Object.prototype.propertyIsEnumerable; var Kn = (t, e, r) => e in t ? Rt(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, x = (t, e) => { for (var r in e || (e = {})) on.call(e, r) && Kn(t, r, e[r]); if (mi) for (var r of mi(e)) Zn.call(e, r) && Kn(t, r, e[r]); return t }, z = (t, e) => $s(t, zs(e)), Qn = t => Rt(t, "__esModule", { value: !0 }); var Jn = (t, e) => { var r = {}; for (var i in t) on.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]); if (t != null && mi) for (var i of mi(t)) e.indexOf(i) < 0 && Zn.call(t, i) && (r[i] = t[i]); return r }; var sn = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Ys = (t, e) => { for (var r in e) Rt(t, r, { get: e[r], enumerable: !0 }) }, eo = (t, e, r, i) => { if (e && typeof e == "object" || typeof e == "function") for (let o of Gs(e)) !on.call(t, o) && (r || o !== "default") && Rt(t, o, { get: () => e[o], enumerable: !(i = Us(e, o)) || i.enumerable }); return t }, an = (t, e) => eo(Qn(Rt(t != null ? js(Vs(t)) : {}, "default", !e && t && t.__esModule ? { get: () => t.default, enumerable: !0 } : { value: t, enumerable: !0 })), t), Ws = (t => (e, r) => t && t.get(e) || (r = eo(Qn({}), e, 1), t && t.set(e, r), r))(typeof WeakMap != "undefined" ? new WeakMap : 0); var ln = (t, e, r) => { if (!e.has(t)) throw TypeError("Cannot " + r) }; var n = (t, e, r) => (ln(t, e, "read from private field"), r ? r.call(t) : e.get(t)), d = (t, e, r) => { if (e.has(t)) throw TypeError("Cannot add the same private member more than once"); e instanceof WeakSet ? e.add(t) : e.set(t, r) }, p = (t, e, r, i) => (ln(t, e, "write to private field"), i ? i.call(t, r) : e.set(t, r), r); var et = (t, e, r) => (ln(t, e, "access private method"), r); var F = (t, e, r) => new Promise((i, o) => { var s = c => { try { a(r.next(c)) } catch (u) { o(u) } }, l = c => { try { a(r.throw(c)) } catch (u) { o(u) } }, a = c => c.done ? i(c.value) : Promise.resolve(c.value).then(s, l); a((r = r.apply(t, e)).next()) }); var us = sn((ds, Ni) => { (function (t) { var e = !1, r, i; function o() { if (typeof r != "undefined") return r; var h = document.documentElement, f = document.createElement("div"); return f.setAttribute("style", "width:99px;height:99px;position:absolute;top:-9999px;overflow:scroll;"), h.appendChild(f), r = f.offsetWidth - f.clientWidth, h.removeChild(f), r } function s() { return document.documentElement.scrollHeight > window.innerHeight } function l(h) { if (!(typeof document == "undefined" || e)) { var f = document.documentElement; i = window.pageYOffset, s() ? f.style.width = "calc(100% - " + o() + "px)" : f.style.width = "100%", f.style.position = "fixed", f.style.top = -i + "px", f.style.overflow = "hidden", e = !0 } } function a() { if (!(typeof document == "undefined" || !e)) { var h = document.documentElement; h.style.width = "", h.style.position = "", h.style.top = "", h.style.overflow = "", window.scroll(0, i), e = !1 } } function c() { if (e) { a(); return } l() } var u = { on: l, off: a, toggle: c }; typeof Ni != "undefined" && typeof Ni.exports != "undefined" ? Ni.exports = u : t.noScroll = u })(ds) }); var Ls = sn((ws, Wi) => { (function (t, e, r) { typeof Wi != "undefined" && Wi.exports ? Wi.exports = r() : t[e] = r() })(ws, "subtag", function () { var t = "", e = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/; function r(a) { return a.match(e) || [] } function i(a) { return r(a).filter(function (c, u) { return c && u }) } function o(a) { return a = r(a), { language: a[1] || t, extlang: a[2] || t, script: a[3] || t, region: a[4] || t } } function s(a, c, u) { Object.defineProperty(a, c, { value: u, enumerable: !0 }) } function l(a, c, u) { function h(f) { return r(f)[a] || t } s(h, "pattern", c), s(o, u, h) } return l(1, /^[a-zA-Z]{2,3}$/, "language"), l(2, /^[a-zA-Z]{3}$/, "extlang"), l(3, /^[a-zA-Z]{4}$/, "script"), l(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), s(o, "split", i), o }) }); var Is = sn((Gn, Vn) => { var wl = function () { var t = {}, e = 1e-10, r = Math.PI / 180, i = 180 / Math.PI, o = 6378137, s = 20037508342789244e-9; function l(c) { return Number(c) === c && c % 1 !== 0 } function a(c) { if (c = c || {}, this.size = c.size || 256, this.expansion = c.antimeridian === !0 ? 2 : 1, !t[this.size]) { var u = this.size, h = t[this.size] = {}; h.Bc = [], h.Cc = [], h.zc = [], h.Ac = []; for (var f = 0; f < 30; f++)h.Bc.push(u / 360), h.Cc.push(u / (2 * Math.PI)), h.zc.push(u / 2), h.Ac.push(u), u *= 2 } this.Bc = t[this.size].Bc, this.Cc = t[this.size].Cc, this.zc = t[this.size].zc, this.Ac = t[this.size].Ac } return a.prototype.px = function (c, u) { if (l(u)) { var h = this.size * Math.pow(2, u), f = h / 2, b = h / 360, A = h / (2 * Math.PI), v = h, y = Math.min(Math.max(Math.sin(r * c[1]), -.9999), .9999), S = f + c[0] * b, T = f + .5 * Math.log((1 + y) / (1 - y)) * -A; return S > v * this.expansion && (S = v * this.expansion), T > v && (T = v), [S, T] } else { var f = this.zc[u], y = Math.min(Math.max(Math.sin(r * c[1]), -.9999), .9999), S = Math.round(f + c[0] * this.Bc[u]), T = Math.round(f + .5 * Math.log((1 + y) / (1 - y)) * -this.Cc[u]); return S > this.Ac[u] * this.expansion && (S = this.Ac[u] * this.expansion), T > this.Ac[u] && (T = this.Ac[u]), [S, T] } }, a.prototype.ll = function (c, u) { if (l(u)) { var h = this.size * Math.pow(2, u), f = h / 360, b = h / (2 * Math.PI), A = h / 2, v = (c[1] - A) / -b, y = (c[0] - A) / f, S = i * (2 * Math.atan(Math.exp(v)) - .5 * Math.PI); return [y, S] } else { var v = (c[1] - this.zc[u]) / -this.Cc[u], y = (c[0] - this.zc[u]) / this.Bc[u], S = i * (2 * Math.atan(Math.exp(v)) - .5 * Math.PI); return [y, S] } }, a.prototype.bbox = function (c, u, h, f, b) { f && (u = Math.pow(2, h) - 1 - u); var A = [c * this.size, (+u + 1) * this.size], v = [(+c + 1) * this.size, u * this.size], y = this.ll(A, h).concat(this.ll(v, h)); return b === "900913" ? this.convert(y, "900913") : y }, a.prototype.xyz = function (c, u, h, f) { f === "900913" && (c = this.convert(c, "WGS84")); var b = [c[0], c[1]], A = [c[2], c[3]], v = this.px(b, u), y = this.px(A, u), S = [Math.floor(v[0] / this.size), Math.floor((y[0] - 1) / this.size)], T = [Math.floor(y[1] / this.size), Math.floor((v[1] - 1) / this.size)], D = { minX: Math.min.apply(Math, S) < 0 ? 0 : Math.min.apply(Math, S), minY: Math.min.apply(Math, T) < 0 ? 0 : Math.min.apply(Math, T), maxX: Math.max.apply(Math, S), maxY: Math.max.apply(Math, T) }; if (h) { var B = { minY: Math.pow(2, u) - 1 - D.maxY, maxY: Math.pow(2, u) - 1 - D.minY }; D.minY = B.minY, D.maxY = B.maxY } return D }, a.prototype.convert = function (c, u) { return u === "900913" ? this.forward(c.slice(0, 2)).concat(this.forward(c.slice(2, 4))) : this.inverse(c.slice(0, 2)).concat(this.inverse(c.slice(2, 4))) }, a.prototype.forward = function (c) { var u = [o * c[0] * r, o * Math.log(Math.tan(Math.PI * .25 + .5 * c[1] * r))]; return u[0] > s && (u[0] = s), u[0] < -s && (u[0] = -s), u[1] > s && (u[1] = s), u[1] < -s && (u[1] = -s), u }, a.prototype.inverse = function (c) { return [c[0] * i / o, (Math.PI * .5 - 2 * Math.atan(Math.exp(-c[1] / o))) * i] }, a }(); typeof Vn != "undefined" && typeof Gn != "undefined" && (Vn.exports = Gn = wl) }); var Bl = {}; Ys(Bl, { MapboxAddressAutofill: () => vt, MapboxAddressConfirmation: () => Ve, MapboxAddressMinimap: () => Mt, MapboxHTMLEvent: () => M, MapboxSearchBox: () => yt, autofill: () => Ns, config: () => R, confirmAddress: () => $i, getAutofillSearchText: () => pt, getFormAutofillValues: () => Hi }); var to = document.implementation.createHTMLDocument(); function J(t, e) { let r = {}; for (let [i, o] of Object.entries(e)) r[i] = t.querySelector(o); return r } function ro(t) { return Array.from(t.childNodes || []).filter(e => e.nodeType === Node.ELEMENT_NODE) } function j(t) { let e = document.createElement("template"); return e.innerHTML = t, e.content.firstElementChild } function io(t) { let e = to.createElement("style"); return e.textContent = t, to.head.appendChild(e), e.sheet } function no(t) { return window.getComputedStyle(t).display !== "none" } function ce(t, e) { if (!t) return; Object.getOwnPropertyDescriptor(t.constructor.prototype, "value").set.call(t, e); let i = t; i._valueTracker && i._valueTracker.setValue(""); let o = new Event("input", { bubbles: !0 }); o.simulated = !0, t.dispatchEvent(o); let s = new Event("change", { bubbles: !0 }); s.simulated = !0, t.dispatchEvent(s) } function gi(t, e = !1) { let r, i, o = t.getBoundingClientRect(); if (t.style.display === "none" || o.height === 0 && o.width === 0) { let s = t.cloneNode(e); t.parentElement.appendChild(s), s.style.setProperty("display", "block", "important"); let l = s.getBoundingClientRect(); r = l.width, i = l.height, s.style.setProperty("display", "none"), s.remove() } else r = o.width, i = o.height; return { height: Math.floor(i), width: Math.floor(r) } } function oo(t) { let e = document.createElement("style"); e.innerHTML = t, document.head.appendChild(e) } var Xs = new RegExp("[_a-zA-Z]+[_a-zA-Z0-9-]*", "g"), qs = new RegExp(`\\.${Xs.source}`, "g"), Ks = new RegExp("^\\s*(@(?:media|supports)[^{]*){(.*)}\\s*$"); function Bt(t, e) { return t.replace(qs, r => "." + e(r.slice(1))) } function cn(t, e) {
    let i = io(t).cssRules; function o(l) {
      if (l instanceof CSSStyleRule) return `${Bt(l.selectorText, e)} { ${l.style.cssText} }`; let a = Ks.exec(l.cssText.split(`
`).join("")); if (a && a.length > 2) { let c = a[1], u = a[2]; return `${c} { ${cn(u, e)} }` } return l.cssText
    } let s = ""; for (let l of Array.from(i)) s += o(l) + `

`; return s.trim()
  } function dn(t, e) { let r = Array.from(t.querySelectorAll("[class]")); r.push(t); for (let i of r) { let { classList: o } = i; for (let s of Array.from(o)) o.remove(s), o.add(e(s)) } return t } var Zs = Object.defineProperty, Qs = Object.defineProperties, Js = Object.getOwnPropertyDescriptors, yi = Object.getOwnPropertySymbols, lo = Object.prototype.hasOwnProperty, co = Object.prototype.propertyIsEnumerable, so = (t, e, r) => e in t ? Zs(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, H = (t, e) => { for (var r in e || (e = {})) lo.call(e, r) && so(t, r, e[r]); if (yi) for (var r of yi(e)) co.call(e, r) && so(t, r, e[r]); return t }, rt = (t, e) => Qs(t, Js(e)), mn = (t, e) => { var r = {}; for (var i in t) lo.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]); if (t != null && yi) for (var i of yi(t)) e.indexOf(i) < 0 && co.call(t, i) && (r[i] = t[i]); return r }, gn = (t, e, r) => { if (!e.has(t)) throw TypeError("Cannot " + r) }, de = (t, e, r) => (gn(t, e, "read from private field"), r ? r.call(t) : e.get(t)), Fe = (t, e, r) => { if (e.has(t)) throw TypeError("Cannot add the same private member more than once"); e instanceof WeakSet ? e.add(t) : e.set(t, r) }, Ot = (t, e, r, i) => (gn(t, e, "write to private field"), i ? i.call(t, r) : e.set(t, r), r), xi = (t, e, r) => (gn(t, e, "access private method"), r), ue = (t, e, r) => new Promise((i, o) => { var s = c => { try { a(r.next(c)) } catch (u) { o(u) } }, l = c => { try { a(r.throw(c)) } catch (u) { o(u) } }, a = c => c.done ? i(c.value) : Promise.resolve(c.value).then(s, l); a((r = r.apply(t, e)).next()) }), uo = "https://api.mapbox.com/autofill/v1", ea = "suggest", ta = "retrieve", ra = `${uo}/${ea}`, ia = `${uo}/${ta}`, _ = class { constructor(t, e) { if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`); if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90"); if (this.lng > 180 || this.lng < -180) throw new Error("Invalid LngLat longitude value: must be between -180 and 180") } toArray() { return [this.lng, this.lat] } toString() { return `LngLat(${this.lng}, ${this.lat})` } static convert(t) { if (t instanceof _) return new _(t.lng, t.lat); if (Array.isArray(t) && t.length === 2) return new _(Number(t[0]), Number(t[1])); if (!Array.isArray(t) && typeof t == "object" && t !== null && ("lng" in t || "lon" in t) && "lat" in t) return new _(Number("lng" in t ? t.lng : t.lon), Number(t.lat)); throw new Error("`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") } }, he = class { constructor(t, e) { this._sw = _.convert(t), this._ne = _.convert(e) } getSouthWest() { return this._sw } getNorthEast() { return this._ne } getNorthWest() { return new _(this.getWest(), this.getNorth()) } getSouthEast() { return new _(this.getEast(), this.getSouth()) } getWest() { return this._sw.lng } getSouth() { return this._sw.lat } getEast() { return this._ne.lng } getNorth() { return this._ne.lat } toArray() { return [this._sw.toArray(), this._ne.toArray()] } toFlatArray() { return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat] } toString() { return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})` } static convert(t) { if (!t) throw new Error("Invalid LngLatBounds convert value: falsy"); if (t instanceof he) return new he(t.getSouthWest(), t.getNorthEast()); if (Array.isArray(t) && t.length === 2) return new he(_.convert(t[0]), _.convert(t[1])); if (Array.isArray(t) && t.length === 4) return new he(_.convert([t[0], t[1]]), _.convert([t[2], t[3]])); throw new Error("`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]") } }; function na() { let e = (Math.random().toString(16) + Date.now().toString(16) + Math.random().toString(16)).replace(/\./g, ""); return [e.slice(0, 8), e.slice(8, 12), "4" + e.slice(12, 15) + "-8" + e.slice(15, 18), e.slice(18, 30)].join("-") } var ee = class { constructor(t) { this.id = t != null ? t : na() } toString() { return this.id } static convert(t) { return new ee(t instanceof ee ? t.id : t.toString()) } }, oa = "Unknown error", sa = class extends Error { constructor(t, e) { super(String(t.message || t.error || oa)); this.name = "MapboxError", this.statusCode = e } toString() { return `${this.name} (${this.statusCode}): ${this.message}` } }; function _e(t) { return ue(this, null, function* () { if (!t.ok) { let e = yield t.json(); throw new sa(e, t.status) } }) } var ao = globalThis.fetch, aa = globalThis.AbortController; function Ie() { if (!ao) throw new Error("Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue."); return { fetch: ao, AbortController: aa } } function Ne(...t) { let e = []; for (let r of t) { if (!r) continue; let i = Object.entries(r); for (let [o, s] of i) s != null && e.push(`${o}=${encodeURIComponent(String(s))}`) } return e.join("&") } var hn, ho, po = class { constructor(t = {}) { Fe(this, hn); let e = t, { accessToken: r } = e, i = mn(e, ["accessToken"]); this.accessToken = r, this.defaults = H(H({}, po.defaults), i) } suggest(t, e) { return ue(this, null, function* () { if (!t) throw new Error("searchText is required"); let { sessionToken: r, signal: i } = e, o = rt(H(H({}, this.defaults), e), { sessionToken: r }), s = new URL(`${ra}/${encodeURIComponent(t)}`); s.search = xi(this, hn, ho).call(this, o); let { fetch: l } = Ie(), a = yield l(s.toString(), { signal: i }); yield _e(a); let c = yield a.json(); return rt(H({}, c), { suggestions: c.suggestions.map(u => rt(H({}, u), { original_search_text: t })), url: s.toString() }) }) } retrieve(t, e) { return ue(this, null, function* () { if (!t) throw new Error("suggestion is required"); if (!this.canRetrieve(t)) throw new Error("suggestion cannot be retrieved"); let { sessionToken: r, signal: i } = e, o = ee.convert(r), s = new URL(`${ia}/${t.action.id}`); s.search = Ne({ access_token: this.accessToken, session_token: o.id }); let { fetch: l } = Ie(), a = yield l(s.toString(), { signal: i }); yield _e(a); let c = yield a.json(); return c.url = s.toString(), c }) } canRetrieve(t) { let e = t.action; return typeof (e == null ? void 0 : e.id) == "string" } }, Ht = po; hn = new WeakSet; ho = function (t) { return Ne({ types: "address", streets: !0, access_token: this.accessToken, language: t.language, country: t.country, limit: t.limit }, t.sessionToken && { session_token: ee.convert(t.sessionToken).id }, t.proximity && { proximity: typeof t.proximity == "string" ? t.proximity : _.convert(t.proximity).toArray().join(",") }, t.bbox && { bbox: typeof t.bbox == "string" ? t.bbox : he.convert(t.bbox).toFlatArray().join(",") }) }; Ht.defaults = { language: "en", proximity: "ip" }; var Ai = "https://api.mapbox.com/search/searchbox/v1", la = "suggest", ca = "retrieve", da = "category", ua = "reverse", ha = `${Ai}/${la}`, pa = `${Ai}/${ca}`, fa = `${Ai}/${da}`, ma = `${Ai}/${ua}`, vi, pn, fo = class { constructor(t = {}) { Fe(this, vi); let e = t, { accessToken: r } = e, i = mn(e, ["accessToken"]); this.accessToken = r, this.defaults = H(H({}, fo.defaults), i) } suggest(t, e) { return ue(this, null, function* () { if (!t) throw new Error("searchText is required"); let { sessionToken: r, signal: i } = e, o = rt(H(H({}, this.defaults), e), { q: t, sessionToken: r }); if (o.eta_type && (!o.origin || !o.navigation_profile)) throw new Error("to provide eta estimate: eta, navigation_profile, and origin are required"); if (o.origin && !o.navigation_profile) throw new Error("to provide distance estimate: both navigation_profile and origin are required"); let s = new URL(ha); s.search = xi(this, vi, pn).call(this, o); let { fetch: l } = Ie(), a = yield l(s.toString(), { signal: i }); yield _e(a); let c = yield a.json(); return c.url = s.toString(), c }) } retrieve(t, e) { return ue(this, null, function* () { if (!t) throw new Error("suggestion is required"); let { sessionToken: r, signal: i } = e, o = ee.convert(r), s = new URL(`${pa}/${encodeURIComponent(t.mapbox_id)}`); s.search = Ne({ access_token: this.accessToken, session_token: o.id }); let { fetch: l } = Ie(), a = yield l(s.toString(), { signal: i }); yield _e(a); let c = yield a.json(); return c.url = s.toString(), c }) } category(t) { return ue(this, arguments, function* (e, r = {}) { if (!e) throw new Error("category is required"); let i = H(H({}, this.defaults), r), o = new URL(`${fa}/${encodeURIComponent(e)}`); o.search = xi(this, vi, pn).call(this, i); let { fetch: s } = Ie(), l = yield s(o.toString(), { signal: i.signal }); yield _e(l); let a = yield l.json(); return a.url = o.toString(), a }) } reverse(t) { return ue(this, arguments, function* (e, r = {}) { if (!e) throw new Error("lngLat is required"); let [i, o] = typeof e == "string" ? e.split(",").map(h => parseFloat(h)) : _.convert(e).toArray(); if (isNaN(i) || isNaN(o)) throw new Error("lngLat is required"); let s = H(H({}, this.defaults), r), l = new URL(ma); l.search = Ne({ access_token: this.accessToken, language: s.language, limit: s.limit, longitude: i, latitude: o }, s.types && { types: typeof s.types == "string" ? s.types : [...s.types].join(",") }); let { fetch: a } = Ie(), c = yield a(l.toString(), { signal: s.signal }); yield _e(c); let u = yield c.json(); return u.url = l.toString(), u }) } }, vn = fo; vi = new WeakSet; pn = function (t) { return Ne({ q: t.q, access_token: this.accessToken, language: t.language, limit: t.limit, navigation_profile: t.navigation_profile, route: t.route, route_geometry: t.route_geometry, sar_type: t.sar_type, time_deviation: t.time_deviation, eta_type: t.eta_type, country: t.country, poi_category: t.poi_category, radius: t.radius, user_id: t.user_id, rich_metadata_provider: t.rich_metadata_provider, poi_category_exclusions: t.poi_category_exclusions }, t.sessionToken && { session_token: ee.convert(t.sessionToken).id }, t.proximity && { proximity: typeof t.proximity == "string" ? t.proximity : _.convert(t.proximity).toArray().join(",") }, t.origin && { origin: typeof t.origin == "string" ? t.origin : _.convert(t.origin).toArray().join(",") }, t.bbox && { bbox: typeof t.bbox == "string" ? t.bbox : he.convert(t.bbox).toFlatArray().join(",") }, t.types && { types: typeof t.types == "string" ? t.types : [...t.types].join(",") }) }; vn.defaults = { language: "en" }; var ga = "https://api.mapbox.com/autofill/v1", va = "retrieve", ba = `${ga}/${va}`, fn, mo, go = class { constructor(t = {}) { Fe(this, fn); let e = t, { accessToken: r } = e, i = mn(e, ["accessToken"]); this.accessToken = r, this.defaults = H(H({}, go.defaults), i) } validate(t, e) { return ue(this, null, function* () { if (!t) throw new Error("searchText is required"); let { sessionToken: r, signal: i } = e, o = rt(H(H({}, this.defaults), e), { sessionToken: r }), s = new URL(`${ba}/${encodeURIComponent(t)}`); s.search = xi(this, fn, mo).call(this, o); let { fetch: l } = Ie(), a = yield l(s.toString(), { signal: i }); yield _e(a); let c = yield a.json(); return c.url = s.toString(), c.features.length > 0 && (c.features = [c.features[0]]), c }) } }, bn = go; fn = new WeakSet; mo = function (t) { return Ne({ access_token: this.accessToken, language: t.language, country: t.country }, t.sessionToken && { session_token: ee.convert(t.sessionToken).id }, t.proximity && { proximity: typeof t.proximity == "string" ? t.proximity : _.convert(t.proximity).toArray().join(",") }, t.bbox && { bbox: typeof t.bbox == "string" ? t.bbox : he.convert(t.bbox).toFlatArray().join(",") }) }; bn.defaults = { language: "en", proximity: "ip" }; var vo = "https://api.mapbox.com/geocoding/v5", Fl = `${vo}/mapbox.places`, Nl = `${vo}/mapbox.places-permanent`, ya, xa; ya = new WeakSet; xa = function (t, e = !1) { return e && ["proximity", "autocomplete", "fuzzyMatch", "bbox"].forEach(r => { r in t && delete t[r] }), Ne({ access_token: this.accessToken, language: t.language, country: t.country, limit: t.limit, autocomplete: t.autocomplete, fuzzyMatch: t.fuzzyMatch, routing: t.routing, worldview: t.worldview }, t.proximity && { proximity: typeof t.proximity == "string" ? t.proximity : _.convert(t.proximity).toArray().join(",") }, t.bbox && { bbox: typeof t.bbox == "string" ? t.bbox : he.convert(t.bbox).toFlatArray().join(",") }, t.types && { types: typeof t.types == "string" ? t.types : [...t.types].join(",") }) }; var yn = (t => (t.exact = "exact", t.high = "high", t.medium = "medium", t.low = "low", t))(yn || {}), Pt, xn = class { constructor() { Fe(this, Pt, {}) } addEventListener(t, e) { let r = de(this, Pt); r[t] || (r[t] = []), r[t].push(e) } removeEventListener(t, e) { let r = de(this, Pt); if (!r[t]) return; let i = r[t], o = i.indexOf(e); o !== -1 && i.splice(o, 1) } fire(t, e) { let r = de(this, Pt); if (!r[t]) return; let i = r[t]; for (let o of i) o(e) } }; Pt = new WeakMap; function An(t, e, r) { let i = null; return (...o) => { i !== null && clearTimeout(i); let s = r && r(); i = setTimeout(() => { i = null, !(s == null ? void 0 : s.aborted) && t(...o) }, e) } } function un() { let { AbortController: t } = Ie(); return new t } var tt, ke, bi, it = class extends xn { constructor(t, e = 0) { super(); this.sessionToken = new ee, Fe(this, tt, void 0), Fe(this, ke, un()), Fe(this, bi, void 0), Ot(this, bi, An((r, ...i) => ue(this, [r, ...i], function* (o, s = {}) { if (de(this, ke).abort(), Ot(this, ke, un()), !o) { Ot(this, tt, null), this.fire("suggest", de(this, tt)); return } try { let l = yield this.search.suggest(o, rt(H({ sessionToken: this.sessionToken }, s), { signal: de(this, ke).signal })); Ot(this, tt, l), this.fire("suggest", l) } catch (l) { if (l.name === "AbortError") return; this.fire("suggesterror", l) } }), e, () => de(this, ke).signal)), Object.defineProperties(this, { search: { value: t, writable: !1 }, debounce: { value: e, writable: !1 } }) } get suggestions() { return de(this, tt) } suggest(t, e) { return de(this, bi).call(this, t, e), new Promise((r, i) => { let o, s; o = l => { this.removeEventListener("suggest", o), this.removeEventListener("suggesterror", s), r(l) }, s = l => { this.removeEventListener("suggest", o), this.removeEventListener("suggesterror", s), i(l) }, this.addEventListener("suggest", o), this.addEventListener("suggesterror", s) }) } clear() { this.suggest("") } retrieve(t, e) { return ue(this, null, function* () { let r = yield this.search.retrieve(t, H({ sessionToken: this.sessionToken }, e)); return this.fire("retrieve", r), r }) } canRetrieve(t) { return this.search.canRetrieve ? this.search.canRetrieve(t) : !0 } canSuggest(t) { return this.search.canSuggest ? this.search.canSuggest(t) : !0 } abort() { de(this, ke).abort(), Ot(this, ke, un()) } }; tt = new WeakMap; ke = new WeakMap; bi = new WeakMap; function nt(t) { let { properties: e } = t; return H({}, e) } var En = 1.4; function bo(t, e, r = .5) { let { center: i, zoom: o } = t.cameraForBounds(e), s = Math.max(o - r, 0); return { center: i, zoom: s, speed: En } } function yo(t) { switch (t) { case "street": return 15; case "neighborhood": case "postcode": case "locality": case "oaza": return 14; case "place": case "city": return 13; case "district": return 9; case "region": case "prefecture": return 6; case "country": return 4; default: return 16 } } function Ei(t, e) { return `https://api.mapbox.com/styles/v1/${t}/${e}/static/` } var Si = '<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.8 3.8a1 1 0 0 1 1.4 0L9 7.58l3.8-3.8a1 1 0 1 1 1.4 1.42L10.42 9l3.8 3.8a1 1 0 0 1-1.42 1.4L9 10.42l-3.8 3.8a1 1 0 0 1-1.4-1.42L7.58 9l-3.8-3.8a1 1 0 0 1 0-1.4Z" fill="currentColor"/></svg>'; var xo = '<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg"><path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/></svg>'; var Ao = Ei("mapbox", "satellite-streets-v11"), Eo = "20d01", So = ["mapbox.com", "mapbox.cn", "tilestream.net"], Mo = j(`
<template>
  <div class="MapboxSearch">
    <div class="Label" role="label" aria-live="polite" aria-atomic="true">
    </div>
    <div class="Results" aria-hidden="true">
      <div class="ResultsList" role="listbox">
      </div>
      <div class="ResultsAttribution" aria-hidden="true">
        <a href="https://www.mapbox.com/search-service" target="_blank" tabindex="-1">
          Powered by Mapbox
        </a>
      </div>
    </div>
  </div>
</template>
`), To = j(`
<template>
  <div class="Suggestion" role="option" tabindex="-1">
    <div class="SuggestionIcon" aria-hidden="true"></div>
    <div class="SuggestionText">
      <div class="SuggestionName"></div>
      <div class="SuggestionDesc"></div>
    </div>
  </div>
</template>
`), wo = j(`
<template>
  <div class="SearchBox">
    <div class="SearchIcon"></div>
    <input class="Input" type="text" />
    <div class="ActionIcon">
      <button aria-label="Clear" class="ClearBtn">${Si}</button>
      <div class="LoadingIcon">${xo}</div>
    </div>
  </div>
</template>
`); function pe() { return "mbx" + new ee().id.slice(0, 8) } function ot(t) { try { return JSON.parse(t) } catch (e) { return null } } function De(t, e) { if (t == null || e == null || typeof t != "object" || typeof e != "object") return t === e; let r = Object.keys(t), i = Object.keys(e); if (r.length !== i.length) return !1; for (let o of r) if (!De(t[o], e[o])) return !1; return !0 } function Sn(t, e) { let r = Math.pow(10, e); return Math.round(t * r) / r } function Lo(t) { return Boolean(t.match(/localhost|[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|::1|\.local|^$/gi)) } function Co(t) { return Boolean(So.some(e => t.includes(e))) } var st, je, $e, W = class extends HTMLElement { constructor() { super(...arguments); d(this, st, pe()); d(this, je, void 0); d(this, $e, e => `${n(this, st)}--${e}`) } get template() { return null } get templateStyle() { return null } get templateUserStyle() { return null } clonedCallback(e, r) { let i = l => l.replace(e, r); dn(this, i); let o = Array.from(this.querySelectorAll("style")); for (let l of o) l.textContent = Bt(l.textContent, i); o.length && p(this, je, o[o.length - 1]); let s = Array.from(this.querySelectorAll(`[id^="${e}"]`)); for (let l of s) l.id = l.id.replace(e, r) } connectedCallback() { if (this.childElementCount > 0) { let o = this.dataset.seed, s = n(this, st); o && o !== s && (this.clonedCallback(o, s), this.dataset.seed = s); return } this.dataset.seed = n(this, st); let e = this.template; if (e) { let o = this.prepareTemplate(e); this.appendChild(o) } let r = this.templateStyle; if (r) { let o = document.createElement("style"); o.textContent = this.prepareCSS(r), this.appendChild(o) } let i = document.createElement("style"); this.templateUserStyle && (i.textContent = this.prepareCSS(this.templateUserStyle)), this.appendChild(i), p(this, je, i) } prepareTemplate(e) { let r = e.content.firstElementChild; return dn(r.cloneNode(!0), n(this, $e)) } prepareCSS(e) { return cn(e, n(this, $e)) } updateTemplateUserStyle(e) { !n(this, je) || (n(this, je).textContent = this.prepareCSS(e)) } querySelector(e) { return super.querySelector(Bt(e, n(this, $e))) } querySelectorAll(e) { return super.querySelectorAll(Bt(e, n(this, $e))) } addEventListener(e, r, i) { super.addEventListener(e, r, i) } removeEventListener(e, r, i) { super.removeEventListener(e, r, i) } dispatchEvent(e) { return super.dispatchEvent(e) } }; st = new WeakMap, je = new WeakMap, $e = new WeakMap; var ko = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 16A7 7 0 1 0 9 2a7 7 0 0 0 0 14ZM6.88 4.88a2.58 2.58 0 0 1 1.83-.75h1.08a2.58 2.58 0 0 1 2.59 2.58v.16c0 1-.53 1.94-1.4 2.46l-.56.34c-.27.16-.45.42-.52.71-.03.14-.14.25-.28.25H8.38a.23.23 0 0 1-.24-.25c.08-.91.59-1.74 1.38-2.21l.56-.34c.34-.2.54-.57.54-.96V6.7a.83.83 0 0 0-.83-.83H8.71a.83.83 0 0 0-.84.83v.18a.87.87 0 1 1-1.75 0V6.7c0-.69.28-1.34.76-1.83ZM10 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z" fill="currentColor"/></svg>'; var Io = '<svg width="48" height="56" fill="none" xmlns="http://www.w3.org/2000/svg"><g filter="url(#a)"><path d="m24 50.4 13.79-14.12a18.82 18.82 0 0 0 4.23-20.86 19.23 19.23 0 0 0-7.19-8.6 19.76 19.76 0 0 0-21.66 0c-3.21 2.11-5.71 5.1-7.19 8.6a18.82 18.82 0 0 0 4.23 20.86L24 50.4Z" fill="currentColor"/><path d="M37.26 35.75 24 49.34 10.75 35.76l-.01-.01A18.07 18.07 0 0 1 6.68 15.7a18.48 18.48 0 0 1 6.9-8.26 19 19 0 0 1 20.84 0 18.48 18.48 0 0 1 6.9 8.26 18.07 18.07 0 0 1-4.06 20.04Z" stroke="#fff" stroke-width="1.5"/></g><circle cx="24" cy="22.45" fill="#fff" r="5.85"/><defs><filter id="a" x=".5" y=".6" width="47" height="54.8" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feColorMatrix in="SourceAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/><feOffset dy="1"/><feGaussianBlur stdDeviation="2"/><feColorMatrix values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_17_871"/><feBlend in="SourceGraphic" in2="effect1_dropShadow_17_871" result="shape"/></filter></defs></svg>'; var Ro = `<svg width="24" height="24" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M1.08 14.94 5.625 3.06h1.17l-3.42 11.88H1.08Zm15.885 0L12.42 3.06h-1.17l3.42 11.88h2.295Zm-6.86-1.44H7.946l.128-2.61h1.912l.119 2.61Zm-.217-4.77H8.181l.088-1.8h1.537l.082 1.8ZM9.74 5.49h-1.4l.049-.99h1.306l.045.99Z" fill="currentColor" />
</svg>`; var Bo = `<!-- TODO: I'm not sure if the way I added the circle will "scale" properly, need to check that -->
<svg width="24" height="24" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" stroke="currentColor" stroke-width="1.5" d="M4 7a5 5 0 1 1 10 0c0 3.025-3.28 6.713-5 9-1.72-2.287-5-5.975-5-9z"></path>
    <circle cx="9" cy="7" r="2" fill="currentColor"></circle>
</svg>`; var Oo = `<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
  <path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>
</svg>`; var _t = "1.0.0-beta.17"; var ka = `https://api.mapbox.com/search-js/v${_t}/img/style-toggle-satellite.jpg`, Ia = `https://api.mapbox.com/search-js/v${_t}/img/style-toggle-default.jpg`, Ra = 768 - 1, Ba = `@media only screen and (max-width: ${Ra}px)`, Mn = {
    variables: {
      unit: ["mobile", "16px", "14px"], unitHeader: ["mobile", "24px", "18px"], minWidth: "min(300px, 100vw)", spacing: "0.75em", padding: "0.5em 0.75em", paddingFooterLabel: "0.5em 0.75em", paddingModal: "1.25em", colorText: "rgba(0, 0, 0, 0.75)", colorPrimary: "#4264FB", colorSecondary: "#667F91", colorBackground: "#fff", colorBackgroundHover: "#f5f5f5", colorBackgroundActive: "#f0f0f0", colorBackdrop: "rgba(102, 127, 145, 0.3)", border: "none", borderRadius: "4px", boxShadow: `
      0 0 10px 2px rgba(0, 0, 0, 0.05),
      0 0 6px 1px rgba(0, 0, 0, 0.1),
      0 0 0 1px rgba(0, 0, 0, 0.1)
    `, lineHeight: "1.2em", fontFamily: `
      -apple-system, BlinkMacSystemFont,
      avenir next, avenir,
      segoe ui,
      helvetica neue, helvetica,
      Ubuntu, roboto, noto, arial, sans-serif
    `, fontWeight: "normal", fontWeightSemibold: "600", fontWeightBold: "bold", duration: "150ms", curve: "ease-out"
    }, icons: { close: Si, question: ko, marker: Io, street: Ro, addressMarker: Bo, search: Oo }, images: { styleToggleDefault: Ia, styleToggleSatellite: ka }
  }; function $(t, e = {}) { let r = x(x({}, Mn.variables), e.variables || {}), i = e.cssText || "", o = ""; for (let [s, l] of Object.entries(r)) { if (!Array.isArray(l)) { o += `--${s}: ${l};`; continue } if (l[0] !== "mobile") { let u = JSON.stringify(l); throw new Error(`Unsupported expression in theme variables: ${s} ${u}`) } let [, a, c] = l; i += `${Ba} { ${t} { --${s}: ${a} !important; } }`, o += `--${s}: ${c};` } return i + `${t} { ${o} }` } function V(t, e = {}) { return x(x({}, Mn.icons), e.icons || {})[t] } function Po(t, e = {}) { return x(x({}, Mn.images), e.images || {})[t] } function Ti(t) { return t.split("-")[0] } function Tn(t) { return t.split("-")[1] } function wn(t) { return ["top", "bottom"].includes(Ti(t)) ? "x" : "y" } function Fo(t) { return t === "y" ? "height" : "width" } function Ho(t, e, r) { let { reference: i, floating: o } = t, s = i.x + i.width / 2 - o.width / 2, l = i.y + i.height / 2 - o.height / 2, a = wn(e), c = Fo(a), u = i[c] / 2 - o[c] / 2, h = a === "x", f; switch (Ti(e)) { case "top": f = { x: s, y: i.y - o.height }; break; case "bottom": f = { x: s, y: i.y + i.height }; break; case "right": f = { x: i.x + i.width, y: l }; break; case "left": f = { x: i.x - o.width, y: l }; break; default: f = { x: i.x, y: i.y } }switch (Tn(e)) { case "start": f[a] -= u * (r && h ? -1 : 1); break; case "end": f[a] += u * (r && h ? -1 : 1) }return f } var No = (t, e, r) => F(void 0, null, function* () { let { placement: i = "bottom", strategy: o = "absolute", middleware: s = [], platform: l } = r, a = yield l.isRTL == null ? void 0 : l.isRTL(e), c = yield l.getElementRects({ reference: t, floating: e, strategy: o }), { x: u, y: h } = Ho(c, i, a), f = i, b = {}; for (let A = 0; A < s.length; A++) { let { name: v, fn: y } = s[A], { x: S, y: T, data: D, reset: B } = yield y({ x: u, y: h, initialPlacement: i, placement: f, strategy: o, middlewareData: b, rects: c, platform: l, elements: { reference: t, floating: e } }); u = S != null ? S : u, h = T != null ? T : h, b = z(x({}, b), { [v]: x(x({}, b[v]), D) }), B && (typeof B == "object" && (B.placement && (f = B.placement), B.rects && (c = B.rects === !0 ? yield l.getElementRects({ reference: t, floating: e, strategy: o }) : B.rects), { x: u, y: h } = Ho(c, f, a)), A = -1) } return { x: u, y: h, placement: f, strategy: o, middlewareData: b } }); function Oa(t) { return typeof t != "number" ? function (e) { return x({ top: 0, right: 0, bottom: 0, left: 0 }, e) }(t) : { top: t, right: t, bottom: t, left: t } } function Ft(t) { return z(x({}, t), { top: t.y, left: t.x, right: t.x + t.width, bottom: t.y + t.height }) } function Do(t, e) { return F(this, null, function* () { var r; e === void 0 && (e = {}); let { x: i, y: o, platform: s, rects: l, elements: a, strategy: c } = t, { boundary: u = "clippingAncestors", rootBoundary: h = "viewport", elementContext: f = "floating", altBoundary: b = !1, padding: A = 0 } = e, v = Oa(A), y = a[b ? f === "floating" ? "reference" : "floating" : f], S = Ft(yield s.getClippingRect({ element: (r = yield s.isElement == null ? void 0 : s.isElement(y)) == null || r ? y : y.contextElement || (yield s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)), boundary: u, rootBoundary: h, strategy: c })), T = Ft(s.convertOffsetParentRelativeRectToViewportRelativeRect ? yield s.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: f === "floating" ? z(x({}, l.floating), { x: i, y: o }) : l.reference, offsetParent: yield s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating), strategy: c }) : l[f]); return { top: S.top - T.top + v.top, bottom: T.bottom - S.bottom + v.bottom, left: S.left - T.left + v.left, right: T.right - S.right + v.right } }) } var Pa = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Mi(t) { return t.replace(/left|right|bottom|top/g, e => Pa[e]) } function Ha(t, e, r) { r === void 0 && (r = !1); let i = Tn(t), o = wn(t), s = Fo(o), l = o === "x" ? i === (r ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top"; return e.reference[s] > e.floating[s] && (l = Mi(l)), { main: l, cross: Mi(l) } } var _a = { start: "end", end: "start" }; function _o(t) { return t.replace(/start|end/g, e => _a[e]) } var Fa = ["top", "right", "bottom", "left"], fc = Fa.reduce((t, e) => t.concat(e, e + "-start", e + "-end"), []); var Ln = function (t) { return t === void 0 && (t = {}), { name: "flip", options: t, fn(e) { return F(this, null, function* () { var r; let { placement: i, middlewareData: o, rects: s, initialPlacement: l, platform: a, elements: c } = e, E = t, { mainAxis: u = !0, crossAxis: h = !0, fallbackPlacements: f, fallbackStrategy: b = "bestFit", flipAlignment: A = !0 } = E, v = Jn(E, ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "flipAlignment"]), y = Ti(i), S = f || (y === l || !A ? [Mi(l)] : function (L) { let k = Mi(L); return [_o(L), k, _o(k)] }(l)), T = [l, ...S], D = yield Do(e, v), B = [], He = ((r = o.flip) == null ? void 0 : r.overflows) || []; if (u && B.push(D[y]), h) { let { main: L, cross: k } = Ha(i, s, yield a.isRTL == null ? void 0 : a.isRTL(c.floating)); B.push(D[L], D[k]) } if (He = [...He, { placement: i, overflows: B }], !B.every(L => L <= 0)) { var O, m; let L = ((O = (m = o.flip) == null ? void 0 : m.index) != null ? O : 0) + 1, k = T[L]; if (k) return { data: { index: L, overflows: He }, reset: { placement: k } }; let P = "bottom"; switch (b) { case "bestFit": { var g; let Ce = (g = He.map(Q => [Q, Q.overflows.filter(ne => ne > 0).reduce((ne, nn) => ne + nn, 0)]).sort((Q, ne) => Q[1] - ne[1])[0]) == null ? void 0 : g[0].placement; Ce && (P = Ce); break } case "initialPlacement": P = l }if (i !== P) return { reset: { placement: P } } } return {} }) } } }; var Cn = function (t) { return t === void 0 && (t = 0), { name: "offset", options: t, fn(e) { return F(this, null, function* () { let { x: r, y: i } = e, o = yield function (s, l) { return F(this, null, function* () { let { placement: a, platform: c, elements: u } = s, h = yield c.isRTL == null ? void 0 : c.isRTL(u.floating), f = Ti(a), b = Tn(a), A = wn(a) === "x", v = ["left", "top"].includes(f) ? -1 : 1, y = h && A ? -1 : 1, S = typeof l == "function" ? l(s) : l, { mainAxis: T, crossAxis: D, alignmentAxis: B } = typeof S == "number" ? { mainAxis: S, crossAxis: 0, alignmentAxis: null } : x({ mainAxis: 0, crossAxis: 0, alignmentAxis: null }, S); return b && typeof B == "number" && (D = b === "end" ? -1 * B : B), A ? { x: D * y, y: T * v } : { x: T * v, y: D * y } }) }(e, t); return { x: r + o.x, y: i + o.y, data: o } }) } } }; function Vo(t) { return t && t.document && t.location && t.alert && t.setInterval } function Ee(t) { if (t == null) return window; if (!Vo(t)) { let e = t.ownerDocument; return e && e.defaultView || window } return t } function Dt(t) { return Ee(t).getComputedStyle(t) } function xe(t) { return Vo(t) ? "" : t ? (t.nodeName || "").toLowerCase() : "" } function Yo() { let t = navigator.userAgentData; return t != null && t.brands ? t.brands.map(e => e.brand + "/" + e.version).join(" ") : navigator.userAgent } function fe(t) { return t instanceof Ee(t).HTMLElement } function Be(t) { return t instanceof Ee(t).Element } function In(t) { return typeof ShadowRoot == "undefined" ? !1 : t instanceof Ee(t).ShadowRoot || t instanceof ShadowRoot } function Ci(t) { let { overflow: e, overflowX: r, overflowY: i } = Dt(t); return /auto|scroll|overlay|hidden/.test(e + i + r) } function Na(t) { return ["table", "td", "th"].includes(xe(t)) } function jo(t) { let e = /firefox/i.test(Yo()), r = Dt(t); return r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].includes(r.willChange) || e && r.willChange === "filter" || e && !!r.filter && r.filter !== "none" } function Wo() { return !/^((?!chrome|android).)*safari/i.test(Yo()) } var $o = Math.min, Nt = Math.max, wi = Math.round; function Ae(t, e, r) { var i, o, s, l; e === void 0 && (e = !1), r === void 0 && (r = !1); let a = t.getBoundingClientRect(), c = 1, u = 1; e && fe(t) && (c = t.offsetWidth > 0 && wi(a.width) / t.offsetWidth || 1, u = t.offsetHeight > 0 && wi(a.height) / t.offsetHeight || 1); let h = Be(t) ? Ee(t) : window, f = !Wo() && r, b = (a.left + (f && (i = (o = h.visualViewport) == null ? void 0 : o.offsetLeft) != null ? i : 0)) / c, A = (a.top + (f && (s = (l = h.visualViewport) == null ? void 0 : l.offsetTop) != null ? s : 0)) / u, v = a.width / c, y = a.height / u; return { width: v, height: y, top: A, right: b + v, bottom: A + y, left: b, x: b, y: A } } function Re(t) { return (e = t, (e instanceof Ee(e).Node ? t.ownerDocument : t.document) || window.document).documentElement; var e } function ki(t) { return Be(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function Xo(t) { return Ae(Re(t)).left + ki(t).scrollLeft } function Da(t, e, r) { let i = fe(e), o = Re(e), s = Ae(t, i && function (c) { let u = Ae(c); return wi(u.width) !== c.offsetWidth || wi(u.height) !== c.offsetHeight }(e), r === "fixed"), l = { scrollLeft: 0, scrollTop: 0 }, a = { x: 0, y: 0 }; if (i || !i && r !== "fixed") if ((xe(e) !== "body" || Ci(o)) && (l = ki(e)), fe(e)) { let c = Ae(e, !0); a.x = c.x + e.clientLeft, a.y = c.y + e.clientTop } else o && (a.x = Xo(o)); return { x: s.left + l.scrollLeft - a.x, y: s.top + l.scrollTop - a.y, width: s.width, height: s.height } } function qo(t) { return xe(t) === "html" ? t : t.assignedSlot || t.parentNode || (In(t) ? t.host : null) || Re(t) } function Uo(t) { return fe(t) && getComputedStyle(t).position !== "fixed" ? t.offsetParent : null } function kn(t) { let e = Ee(t), r = Uo(t); for (; r && Na(r) && getComputedStyle(r).position === "static";)r = Uo(r); return r && (xe(r) === "html" || xe(r) === "body" && getComputedStyle(r).position === "static" && !jo(r)) ? e : r || function (i) { let o = qo(i); for (In(o) && (o = o.host); fe(o) && !["html", "body"].includes(xe(o));) { if (jo(o)) return o; o = o.parentNode } return null }(t) || e } function zo(t) { if (fe(t)) return { width: t.offsetWidth, height: t.offsetHeight }; let e = Ae(t); return { width: e.width, height: e.height } } function Ko(t) { let e = qo(t); return ["html", "body", "#document"].includes(xe(e)) ? t.ownerDocument.body : fe(e) && Ci(e) ? e : Ko(e) } function Li(t, e) { var r; e === void 0 && (e = []); let i = Ko(t), o = i === ((r = t.ownerDocument) == null ? void 0 : r.body), s = Ee(i), l = o ? [s].concat(s.visualViewport || [], Ci(i) ? i : []) : i, a = e.concat(l); return o ? a : a.concat(Li(l)) } function Go(t, e, r) { return e === "viewport" ? Ft(function (i, o) { let s = Ee(i), l = Re(i), a = s.visualViewport, c = l.clientWidth, u = l.clientHeight, h = 0, f = 0; if (a) { c = a.width, u = a.height; let b = Wo(); (b || !b && o === "fixed") && (h = a.offsetLeft, f = a.offsetTop) } return { width: c, height: u, x: h, y: f } }(t, r)) : Be(e) ? function (i, o) { let s = Ae(i, !1, o === "fixed"), l = s.top + i.clientTop, a = s.left + i.clientLeft; return { top: l, left: a, x: a, y: l, right: a + i.clientWidth, bottom: l + i.clientHeight, width: i.clientWidth, height: i.clientHeight } }(e, r) : Ft(function (i) { var o; let s = Re(i), l = ki(i), a = (o = i.ownerDocument) == null ? void 0 : o.body, c = Nt(s.scrollWidth, s.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), u = Nt(s.scrollHeight, s.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), h = -l.scrollLeft + Xo(i), f = -l.scrollTop; return Dt(a || s).direction === "rtl" && (h += Nt(s.clientWidth, a ? a.clientWidth : 0) - c), { width: c, height: u, x: h, y: f } }(Re(t))) } function ja(t) { let e = Li(t), r = ["absolute", "fixed"].includes(Dt(t).position) && fe(t) ? kn(t) : t; return Be(r) ? e.filter(i => Be(i) && function (o, s) { let l = s.getRootNode == null ? void 0 : s.getRootNode(); if (o.contains(s)) return !0; if (l && In(l)) { let a = s; do { if (a && o === a) return !0; a = a.parentNode || a.host } while (a) } return !1 }(i, r) && xe(i) !== "body") : [] } var $a = { getClippingRect: function (t) { let { element: e, boundary: r, rootBoundary: i, strategy: o } = t, s = [...r === "clippingAncestors" ? ja(e) : [].concat(r), i], l = s[0], a = s.reduce((c, u) => { let h = Go(e, u, o); return c.top = Nt(h.top, c.top), c.right = $o(h.right, c.right), c.bottom = $o(h.bottom, c.bottom), c.left = Nt(h.left, c.left), c }, Go(e, l, o)); return { width: a.right - a.left, height: a.bottom - a.top, x: a.left, y: a.top } }, convertOffsetParentRelativeRectToViewportRelativeRect: function (t) { let { rect: e, offsetParent: r, strategy: i } = t, o = fe(r), s = Re(r); if (r === s) return e; let l = { scrollLeft: 0, scrollTop: 0 }, a = { x: 0, y: 0 }; if ((o || !o && i !== "fixed") && ((xe(r) !== "body" || Ci(s)) && (l = ki(r)), fe(r))) { let c = Ae(r, !0); a.x = c.x + r.clientLeft, a.y = c.y + r.clientTop } return z(x({}, e), { x: e.x - l.scrollLeft + a.x, y: e.y - l.scrollTop + a.y }) }, isElement: Be, getDimensions: zo, getOffsetParent: kn, getDocumentElement: Re, getElementRects: t => { let { reference: e, floating: r, strategy: i } = t; return { reference: Da(e, kn(r), i), floating: z(x({}, zo(r)), { x: 0, y: 0 }) } }, getClientRects: t => Array.from(t.getClientRects()), isRTL: t => Dt(t).direction === "rtl" }; function Zo(t, e, r, i) { i === void 0 && (i = {}); let { ancestorScroll: o = !0, ancestorResize: s = !0, elementResize: l = !0, animationFrame: a = !1 } = i, c = o && !a, u = s && !a, h = c || u ? [...Be(t) ? Li(t) : [], ...Li(e)] : []; h.forEach(v => { c && v.addEventListener("scroll", r, { passive: !0 }), u && v.addEventListener("resize", r) }); let f, b = null; l && (b = new ResizeObserver(r), Be(t) && !a && b.observe(t), b.observe(e)); let A = a ? Ae(t) : null; return a && function v() { let y = Ae(t); !A || y.x === A.x && y.y === A.y && y.width === A.width && y.height === A.height || r(), A = y, f = requestAnimationFrame(v) }(), l || r(), () => { var v; h.forEach(y => { c && y.removeEventListener("scroll", r), u && y.removeEventListener("resize", r) }), (v = b) == null || v.disconnect(), b = null, a && cancelAnimationFrame(f) } } var Qo = (t, e, r) => No(t, e, x({ platform: $a }, r)); var Ue, Ii, Ri = class { constructor(e, r, i) { d(this, Ue, void 0); d(this, Ii, { placement: "bottom-start", flip: !1, offset: 10 }); this.update = () => F(this, null, function* () { let e = { placement: this.options.placement, middleware: [Cn(this.options.offset), this.options.flip && Ln()].filter(Boolean) }, { x: r, y: i } = yield Qo(this.referenceEl, this.floatingEl, e); Object.assign(this.floatingEl.style, { left: `${r}px`, top: `${i}px` }) }); this.referenceEl = e, this.floatingEl = r, p(this, Ue, x(x({}, n(this, Ii)), i)), this.destroy = Zo(this.referenceEl, this.floatingEl, this.update) } get options() { return n(this, Ue) } set options(e) { p(this, Ue, x(x({}, n(this, Ue)), e)) } }; Ue = new WeakMap, Ii = new WeakMap; var te = "*{box-sizing:border-box!important}[role=button]{cursor:pointer}.MapboxSearch{--width:0;display:none}.Results{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);min-width:var(--minWidth);overflow-y:auto;position:absolute;transform:translateZ(0);transition:visibility var(--duration);width:var(--width);z-index:1000}.Results:not([aria-hidden=true]){visibility:visible}.Results[aria-hidden=true]{animation:fadein var(--duration) var(--curve) reverse forwards;visibility:hidden}.Suggestion{align-items:center;display:flex;padding:var(--padding)}.Suggestion:hover{cursor:pointer}.Suggestion[aria-selected=true]{background-color:var(--colorBackgroundHover)}.Suggestion:active{background-color:var(--colorBackgroundActive)}.SuggestionName{font-weight:var(--fontWeightBold)}.SuggestionIcon{margin-right:6px}.SuggestionIcon[aria-hidden=true]{display:none}.ResultsAttribution{padding:var(--paddingFooterLabel)}.ResultsAttribution a{color:var(--colorSecondary)}.ResultsAttribution a:not(:hover){text-decoration:none}.ResultsList{list-style:none;margin:0;padding:0}.Label{display:none}.SearchBox{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--padding);padding-bottom:0;padding-top:0;position:relative;width:100%}.SearchIcon{fill:#757575;left:.5em}.ActionIcon,.SearchIcon{bottom:0;height:20px;margin:auto 0;position:absolute;top:0;width:20px}.ActionIcon{right:.5em}.ActionIcon>button{background:none;border:none;color:inherit;cursor:pointer;font:inherit;height:100%;outline:inherit;padding:0;width:100%}.ActionIcon>button:hover{background:none!important}.ClearBtn{display:none}.ClearBtn:hover{color:#909090}.LoadingIcon{-moz-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;-webkit-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;display:none;height:100%}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.Input{background-color:transparent;border:0;color:#404040;color:rgba(0,0,0,.75);font:inherit;height:36px;margin:0;overflow:hidden;padding:0 40px;text-overflow:ellipsis;white-space:nowrap;width:100%}.Input::-ms-clear{display:none}.Input:focus{border:thin dotted;border-radius:var(--borderRadius);box-shadow:none;color:#404040;color:rgba(0,0,0,.75);outline:0}mapbox-address-confirmation-feature[aria-hidden=true],mapbox-address-confirmation-no-feature[aria-hidden=true]{display:none}.MapboxAddressConfirmation{align-items:center;background-color:var(--colorBackdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;transform:translateZ(0);z-index:1000}.MapboxAddressConfirmation:not([aria-hidden=true]){animation:fadein var(--duration) var(--curve) forwards;visibility:visible}.MapboxAddressConfirmation[aria-hidden=true]{visibility:hidden}.ContentFeature,.ContentNoFeature{width:var(--minWidth)}.Modal{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--paddingModal);width:100%}@media screen and (max-width:480px){.MapboxAddressConfirmation{align-items:flex-end}.ContentFeature,.ContentNoFeature{width:100%}.Modal{border-bottom-left-radius:0;border-bottom-right-radius:0}}.ModalHeader{align-items:center;color:var(--colorPrimary);display:flex;font-size:var(--unitHeader);font-weight:var(--fontWeightBold);margin-bottom:var(--spacing);user-select:none;width:100%}.ModalMap{height:calc(var(--minWidth)*9/16);margin-left:calc(var(--paddingModal)*-1);width:calc(100% + var(--paddingModal)*2)}.ModalMap[aria-hidden=true]{display:none}.Icon{height:var(--unitHeader);width:var(--unitHeader)}.Icon.IconClose{color:var(--colorSecondary)}.ModalHeaderTitle{flex:1;margin-left:.25em}.ModalFooter{color:var(--colorSecondary);margin-top:var(--spacing);text-align:center}.ModalFooter[aria-hidden=true]{display:none}.ModalSubheader{font-weight:var(--fontWeightBold);user-select:none}.ModalDescription{color:var(--colorPrimary)}.ModalAddress,.ModalSubheader{margin-bottom:var(--spacing)}.ModalAddress.ModalAddressApprove{color:var(--colorPrimary)}.Button{border-radius:var(--borderRadius);cursor:pointer;font-weight:var(--fontWeightSemibold);margin-top:var(--spacing);padding:var(--padding);text-align:center;user-select:none;width:100%}.Button[aria-hidden=true]{display:none}.Button.ButtonPrimary{background-color:var(--colorPrimary);color:var(--colorBackground)}.Button.ButtonSecondary{border:1px solid var(--colorSecondary);color:var(--colorSecondary)}@keyframes fadein{0%{opacity:0}to{opacity:1}}.MapboxAddressMinimap{font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight)}.MapboxAddressMinimap[aria-hidden=true]{display:none}.MinimapImageContainer{border-radius:var(--borderRadius);overflow:hidden}.MinimapImage{height:unset;max-height:unset;max-width:unset;position:relative;width:unset}.MinimapInnerFrame{border:var(--border);border-radius:inherit;height:inherit;left:0;overflow:hidden;position:absolute;top:0;width:inherit}.MinimapMarker{left:50%;position:absolute;top:50%}.MinimapMarker>svg{color:var(--colorPrimary);display:block!important}.MinimapAttributionLogo{bottom:0;left:0;margin:0 0 6px 6px;position:absolute}.MinimapAttributionLogo a{cursor:pointer;display:block;height:23px;width:88px}.MinimapAttributionText{background-color:hsla(0,0%,100%,.65);bottom:0;font:11px/16px Helvetica Neue,Arial,Helvetica,sans-serif;padding:0 5px;position:absolute;right:0}.MinimapAttributionText a{color:rgba(0,0,0,.75);text-decoration:none}.MinimapAttributionText a:hover{color:inherit;text-decoration:underline}.MinimapAttributionText a:not(:first-child){margin-left:3px}.MinimapStyleToggle{background-position:0;background-repeat:no-repeat;background-size:contain;border:2px solid #fff;border-radius:3px;box-shadow:var(--boxShadow);cursor:pointer;height:2em;position:absolute;right:var(--spacing);top:var(--spacing);width:2em}.MinimapFooter{color:var(--colorSecondary);font-family:var(--fontFamily);font-size:var(--unit);margin-top:var(--spacing)}.MinimapFooter[aria-hidden=true]{display:none}.MinimapEditButtons{bottom:26px;display:flex;font-family:var(--fontFamily);position:absolute;right:var(--spacing)}.MinimapEditButtons .Button{box-shadow:var(--boxShadow)}.MinimapButtonCancel{background-color:var(--colorBackground);margin-left:var(--spacing)}.draggable{cursor:move;cursor:grab}.draggable:active{cursor:grabbing}"; var M = class extends CustomEvent { constructor(e, r) { super(e, { composed: !0, detail: r }) } clone(e) { let r = new M(this.type, this.detail); return e && Object.defineProperty(r, "target", { value: e }), r } }; var Jo = "Type in 2 or more characters for results.", es = "When autocomplete results are available use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.", ts = "No search results.", rs = (t, e, r) => `${e} ${e === 1 ? "result is" : "results are"} available. ${t}. ${r} of ${e} is selected.`, is = t => `${t} ${t === 1 ? "result is" : "results are"} available. Use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.`; function Bi(t) { let e = t.currentTarget; (t.key === " " || t.key === "Enter") && (t.preventDefault(), t.stopPropagation(), e.dispatchEvent(new MouseEvent("click", { bubbles: !0, composed: !0 }))) } var ns = "search-listbox__description", at = t => { let e = document.createElement("div"); e.setAttribute("aria-live", "polite"), e.setAttribute("aria-atomic", "true"), e.setAttribute("role", "status"), e.setAttribute("style", "border: 0px;clip: rect(0px, 0px, 0px, 0px);height: 1px;margin-bottom: -1px;margin-right: -1px;overflow: hidden;padding: 0px;position: absolute;white-space: nowrap;width: 1px;"); let r = document.createElement("div"); return r.setAttribute("id", `${t}--${ns}`), e.appendChild(r), e }, Rn = (t, e) => { var i; let r = (i = document.body.querySelector(`[id="${e}--${ns}"]`)) != null ? i : null; r && (r.textContent = t) }, Oi = t => { t.name = t.name + " address-search", t.setAttribute("data-lpignore", "true") }, os = (t, e, r) => { let i = null, o = !e || e.length === 0; if ((t == null ? void 0 : t.length) < 2) i = Jo + " " + es; else if (o) i = ts; else if (r !== void 0) { let s = e[r], l = s.address || s.full_address || s.feature_name; i = rs(l, e.length, r + 1) } else i = is(e.length); return i }; var $t = (t, e) => { switch (e) { case 0: return t.address_line1 || t.matching_name || t.feature_name; case 3: return t.name; case 1: return t.place_name.split(",")[0]; default: return "" } }, ss = (t, e) => { switch (e) { case 0: return t.description; case 3: return t.feature_type === "poi" ? t.full_address : t.place_formatted; case 1: return t.place_name.split(",").splice(1).join(",").trim(); default: return "" } }; function Bn(t, e) { return `${t}-${e}` } var G, Y, lt, me, ct, Ut, dt, zt, as, Pi, za, Gt, Vt, Yt, ut, ht, ze, Wt, Se = class extends W { constructor() { super(...arguments); d(this, zt); d(this, Pi); this.suggestions = null; d(this, G, null); d(this, Y, void 0); d(this, lt, void 0); d(this, me, void 0); d(this, ct, void 0); d(this, Ut, null); d(this, dt, void 0); d(this, Gt, {}); d(this, Vt, {}); d(this, Yt, e => { let { Results: r } = n(this, Y), i = e.target; if (i.dataset.mapboxSuccess) { delete i.dataset.mapboxSuccess; return } let o = i.value; this.renderAriaMessage(), r.setAttribute("aria-busy", "true"), this.dispatchEvent(new M("input", o)) }); this.renderAriaMessage = () => { var r; let e = os((r = this.input) == null ? void 0 : r.value, this.suggestions, this.selectedIndex); Rn(e, this.dataset.seed) }; this.clearAriaMessage = () => { Rn("", this.dataset.seed) }; this.handleSuggest = e => { if (this.suggestions = e, (!e || e.length === 0) && this.renderAriaMessage(), !e) { this.hideResults(); return } et(this, Pi, za).call(this), e.length && et(this, zt, as).call(this); let { Results: r } = n(this, Y); r.setAttribute("aria-busy", "false") }; this.handleError = () => { let { Results: e } = n(this, Y); e.setAttribute("aria-busy", "false"), this.hideResults() }; d(this, ut, e => F(this, null, function* () { let r = this.input; r && (r.dataset.mapboxSuccess = "true"), this.dispatchEvent(new M("select", e)), this.hideResults() })); d(this, ht, () => { let e = this.input; delete e.dataset.mapboxSuccess, this.dispatchEvent(new M("focus")), this.renderAriaMessage(), et(this, zt, as).call(this) }); d(this, ze, () => { document.activeElement !== this.input && (this.dispatchEvent(new M("blur")), this.clearAriaMessage(), this.hideResults()) }); this.handleArrowUp = () => { this.selectedIndex === void 0 ? this.selectedIndex = this.suggestions.length - 1 : this.selectedIndex === 0 ? this.selectedIndex = void 0 : this.selectedIndex = Math.max(0, this.selectedIndex - 1) }; this.handleArrowDown = () => { this.selectedIndex === void 0 ? this.selectedIndex = 0 : this.selectedIndex === this.suggestions.length - 1 ? this.selectedIndex = void 0 : this.selectedIndex = Math.min(this.selectedIndex + 1, this.suggestions.length - 1) }; d(this, Wt, e => { var r; if (!!((r = this.suggestions) == null ? void 0 : r.length)) { if (e.key === "ArrowDown") { e.preventDefault(), this.handleArrowDown(); return } if (e.key === "ArrowUp") { e.preventDefault(), this.handleArrowUp(); return } if (e.key === "Escape") { this.hideResults(); return } if (this.selectedIndex !== void 0) { if (e.key === "Tab") { n(this, ut).call(this, this.suggestions[this.selectedIndex]); return } if (e.key === "Enter") { e.preventDefault(), n(this, ut).call(this, this.suggestions[this.selectedIndex]); return } } } }) } get template() { return Mo } get templateStyle() { return te } get templateUserStyle() { return $(".MapboxSearch", this.theme) } get input() { return n(this, ct) } set input(e) { let r = n(this, ct); r && (r.removeEventListener("input", n(this, Yt)), r.removeEventListener("focus", n(this, ht)), r.removeEventListener("blur", n(this, ze)), r.removeEventListener("keydown", n(this, Wt)), n(this, G) && n(this, G).destroy()), e && (e.addEventListener("input", n(this, Yt)), e.addEventListener("focus", n(this, ht)), e.addEventListener("blur", n(this, ze)), e.addEventListener("keydown", n(this, Wt)), e.setAttribute("role", "combobox"), e.setAttribute("aria-autocomplete", "list"), e.setAttribute("aria-controls", n(this, me)), this.isConnected && p(this, G, new Ri(e, n(this, Y).Results, this.popoverOptions))), p(this, ct, e) } get searchService() { return n(this, Ut) } set searchService(e) { p(this, Ut, e) } get selectedIndex() { return n(this, dt) } set selectedIndex(e) { let r = n(this, dt); p(this, dt, e); let { ResultsList: i } = n(this, Y), o = Bn(n(this, me), e); if (e !== void 0 ? (this.input.setAttribute("aria-activedescendant", o), i.setAttribute("aria-activedescendant", o)) : (this.input.removeAttribute("aria-activedescendant"), i.removeAttribute("aria-activedescendant")), r !== e) { let s = Bn(n(this, me), r), l = i.querySelector(`#${s}`); if (l == null || l.removeAttribute("aria-selected"), l == null || l.setAttribute("tabindex", "-1"), e !== void 0) { let a = i.querySelector(`#${o}`); a == null || a.setAttribute("aria-selected", "true"), a == null || a.setAttribute("tabindex", "0") } } this.renderAriaMessage() } hideResults() { let { Results: e, ResultsList: r } = n(this, Y); e.setAttribute("aria-hidden", "true"), this.input.setAttribute("aria-expanded", "false"), r.removeAttribute("aria-activedescendant"), this.input.removeAttribute("aria-activedescendant") } renderItem(e) { let r = this.prepareTemplate(To); return r.id = Bn(n(this, me), e), r } fillItem(e, r, i, o) { let s = e.querySelector('[class$="SuggestionIcon"]'), l = e.querySelector('[class$="SuggestionName"]'), a = e.querySelector('[class$="SuggestionDesc"]'); this.searchService === 0 ? (s.innerHTML = V(r.accuracy === "street" ? "street" : "addressMarker", this.theme), s.removeAttribute("aria-hidden")) : s.setAttribute("aria-hidden", "true"), l.textContent = a.textContent = "", l.textContent = $t(r, this.searchService), a.textContent = ss(r, this.searchService), i === this.selectedIndex ? e.setAttribute("aria-selected", "true") : e.removeAttribute("aria-selected"), e.setAttribute("aria-posinset", (i + 1).toString()), e.setAttribute("aria-setsize", o.toString()) } get theme() { return n(this, Gt) } set theme(e) { p(this, Gt, e), !(!n(this, Y) || !e) && this.updateTemplateUserStyle($(".MapboxSearch", e)) } get popoverOptions() { return n(this, Vt) } set popoverOptions(e) { p(this, Vt, e), n(this, G) && (n(this, G).options = e, n(this, G).update()) } connectedCallback() { super.connectedCallback(), this.dataSeed = this.dataset.seed, p(this, lt, this.dataset.seed + "-Label"), p(this, me, this.dataset.seed + "-ResultsList"), this.input && this.input.setAttribute("aria-controls", n(this, me)), p(this, Y, J(this, { MapboxSearch: ".MapboxSearch", Results: ".Results", ResultsList: ".ResultsList", Label: ".Label" })); let { Results: e, ResultsList: r, Label: i } = n(this, Y); i.id = n(this, lt), r.id = n(this, me), r.setAttribute("aria-labelledby", n(this, lt)), e.addEventListener("blur", n(this, ze)), !n(this, G) && this.input && p(this, G, new Ri(this.input, n(this, Y).Results, this.popoverOptions)), requestAnimationFrame(() => { n(this, G) && n(this, G).update() }) } disconnectedCallback() { this.input = null; let { Results: e } = n(this, Y); e.removeEventListener("blur", n(this, ze)), n(this, G) && n(this, G).destroy() } focus() { document.activeElement === this.input ? n(this, ht).call(this) : this.input.focus() } blur() { this.input.blur() } updatePopover() { n(this, G) && n(this, G).update() } }; G = new WeakMap, Y = new WeakMap, lt = new WeakMap, me = new WeakMap, ct = new WeakMap, Ut = new WeakMap, dt = new WeakMap, zt = new WeakSet, as = function () { if (!this.suggestions || !this.suggestions.length) return; let { Results: e, MapboxSearch: r } = n(this, Y), i = this.input.getBoundingClientRect(); r.style.setProperty("--width", `${i.width}px`), r.style.setProperty("display", "block"), this.input.setAttribute("aria-expanded", "true"), e.removeAttribute("aria-hidden"), this.selectedIndex = void 0 }, Pi = new WeakSet, za = function () { let { ResultsList: e } = n(this, Y); if (!this.suggestions || !this.suggestions.length) { e.innerHTML = "", this.hideResults(); return } let r = ro(e); if (this.suggestions.length > r.length) for (let i = r.length; i < this.suggestions.length; i++) { let o = this.renderItem(i); r.push(o), o.onmouseenter = () => { this.selectedIndex = i }, o.onmouseleave = () => { this.selectedIndex = void 0 }, e.appendChild(o) } if (this.suggestions.length < r.length) for (let i = this.suggestions.length; i < r.length; i++)r[i].remove(); for (let i of this.suggestions) { let o = this.suggestions.indexOf(i), s = r[o]; this.fillItem(s, i, o, this.suggestions.length), s.onclick = () => { n(this, ut).call(this, i) } } }, Gt = new WeakMap, Vt = new WeakMap, Yt = new WeakMap, ut = new WeakMap, ht = new WeakMap, ze = new WeakMap, Wt = new WeakMap; window.MapboxSearchListbox = Se; window.customElements.get("mapbox-search-listbox") || customElements.define("mapbox-search-listbox", Se); var Ga = new Set(["street-address", "address-line1", "address-line2", "address-line3", "address-level4", "address-level3", "address-level2", "address-level1", "country", "country-name", "postal-code"]), Va = new Set(["off", "on", "true", "false"]); function On(t) { let e = t.parentNode; for (; e;) { if (e instanceof HTMLFormElement) return e; e = e.parentNode } return null } function Xt(t) { let e = t || document; return Array.from(e.querySelectorAll('input[autocomplete~="address-line1"], input[autocomplete~="street-address"]')) } var Ya = "section-", Wa = "section-default", Xa = "section-shipping", qa = "section-billing"; function qt(t) { let e = Array.from(t.querySelectorAll("[autocomplete]")).filter(i => { let o = i.tagName.toLowerCase(); return o === "input" || o === "select" || o === "textarea" }), r = []; for (let i of e) { if (!no(i)) continue; let o = i.getAttribute("autocomplete") || ""; if (!o || Va.has(o)) continue; let s = o.toLowerCase().split(" "); if (s.length > 3) continue; let l = s[s.length - 1]; if (!Ga.has(l)) continue; s.pop(); let a = Wa; if (s.length) { let c = s[s.length - 1]; c === "shipping" && (a = Xa, s.pop()), c === "billing" && (a = qa, s.pop()) } if (s.length) { let c = s[s.length - 1]; c.startsWith(Ya) && (a = c) } r.push({ input: i, section: a, field: l }) } return r } function Kt(t, e) { let r = [], i = [], o = qt(t), s = null; for (let { input: l, section: a, field: c } of o) { let u = r.length - 1, h = !1; if (r.length ? (i[u] !== a || r[u][c]) && (h = !0) : h = !0, h) { if (s) break; r.push({ [c]: l }), i.push(a), u++ } else r[u][c] = l; l === e && (s = r[u]) } return s != null ? s : {} } function Pn(t, e, r) { var l; let i = Kt(t, e), o = [r.address_line1, r.address_line2, r.address_line3].filter(a => Boolean(a)).join(", "); ce(i["street-address"], o), ce(i["address-line1"], r.address_line1 || ""), ce(i["address-level1"], r.address_level1 || ""), ce(i["address-level2"], r.address_level2 || ""), ce(i["address-level3"], r.address_level3 || ""); let s = r.country_code || ((l = r.metadata) == null ? void 0 : l.iso_3166_1) || ""; if (i.country && i.country instanceof HTMLSelectElement) { let a = i.country.querySelector("option").value, c = a === a.toUpperCase(); ce(i.country, c ? s.toUpperCase() : s) } else ce(i.country, s); ce(i["country-name"], r.country || ""), ce(i["postal-code"], r.postcode || "") } function Hi(t, e) { let r = Kt(t, e), i = {}; for (let [o, s] of Object.entries(r)) (s == null ? void 0 : s.value) && (i[o] = s.value); return i } function pt(t) { let e = []; return t["street-address"] ? e.push(t["street-address"]) : (e.push(t["address-line1"] || ""), e.push(t["address-line2"] || ""), e.push(t["address-line3"] || "")), e.push(t["address-level3"] || ""), e.push(t["address-level2"] || ""), e.push(t["address-level1"] || ""), e.push(t["postal-code"] || ""), t["country-name"] ? e.push(t["country-name"]) : e.push(t.country || ""), e.filter(r => Boolean(r)).join(", ") } function Zt(t, e) { let r = On(e); if (!r) return; let i = nt(t); Pn(r, e, i); let o = Kt(r, e); o["address-line2"] && o["address-line2"].focus() } function ls(t) { var i; let e = {}, r = [t.properties.address_line1, t.properties.address_line2, t.properties.address_line3].filter(o => Boolean(o)).join(", "); return e["street-address"] = r, e["address-line1"] = t.properties.address_line1, e["address-line2"] = t.properties.address_line2, e["address-line3"] = t.properties.address_line3, e["address-level1"] = t.properties.address_level1, e["address-level2"] = t.properties.address_level2, e["address-level3"] = t.properties.address_level3, e.country = (i = t.properties.metadata) == null ? void 0 : i.iso_3166_1, e["country-name"] = t.properties.country, e["postal-code"] = t.properties.postcode, e } function cs(t, e) { for (let [r, i] of Object.entries(t)) if (e[r] !== i) return !0; return !1 } var _i = t => t.filter((e, r, i) => { let o = $t(e, 0); return e.accuracy !== "street" || i.findIndex(s => o === $t(s, 0)) === r }), re = (t, e, r) => { let s = r ? e || "address-line1" : "new-password"; t && (t.autocomplete = s) }, Fi = (t, e, r) => { if (!t || !r) return; re(t, e, !0); let i = { properties: z(x({}, r), { address_line1: r.address_line1 + " ", postcode: null }) }; Zt(i, t), re(t, e, !1), t == null || t.focus() }; var Dn = an(us()); var hs = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"], Hn = hs.join(","), Qt = typeof Element == "undefined" ? function () { } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, ps = function (e, r, i) { var o = Array.prototype.slice.apply(e.querySelectorAll(Hn)); return r && Qt.call(e, Hn) && o.unshift(e), o = o.filter(i), o }, Ka = function (e) { return e.contentEditable === "true" }, fs = function (e) { var r = parseInt(e.getAttribute("tabindex"), 10); return isNaN(r) ? Ka(e) || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : r }, Za = function (e, r) { return e.tabIndex === r.tabIndex ? e.documentOrder - r.documentOrder : e.tabIndex - r.tabIndex }, _n = function (e) { return e.tagName === "INPUT" }, Qa = function (e) { return _n(e) && e.type === "hidden" }, Ja = function (e) { var r = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function (i) { return i.tagName === "SUMMARY" }); return r }, el = function (e, r) { for (var i = 0; i < e.length; i++)if (e[i].checked && e[i].form === r) return e[i] }, tl = function (e) { if (!e.name) return !0; var r = e.form || e.ownerDocument, i = function (a) { return r.querySelectorAll('input[type="radio"][name="' + a + '"]') }, o; if (typeof window != "undefined" && typeof window.CSS != "undefined" && typeof window.CSS.escape == "function") o = i(window.CSS.escape(e.name)); else try { o = i(e.name) } catch (l) { return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", l.message), !1 } var s = el(o, e.form); return !s || s === e }, rl = function (e) { return _n(e) && e.type === "radio" }, il = function (e) { return rl(e) && !tl(e) }, nl = function (e, r) { if (getComputedStyle(e).visibility === "hidden") return !0; var i = Qt.call(e, "details>summary:first-of-type"), o = i ? e.parentElement : e; if (Qt.call(o, "details:not([open]) *")) return !0; if (!r || r === "full") for (; e;) { if (getComputedStyle(e).display === "none") return !0; e = e.parentElement } else if (r === "non-zero-area") { var s = e.getBoundingClientRect(), l = s.width, a = s.height; return l === 0 && a === 0 } return !1 }, ol = function (e) { if (_n(e) || e.tagName === "SELECT" || e.tagName === "TEXTAREA" || e.tagName === "BUTTON") for (var r = e.parentElement; r;) { if (r.tagName === "FIELDSET" && r.disabled) { for (var i = 0; i < r.children.length; i++) { var o = r.children.item(i); if (o.tagName === "LEGEND") return !o.contains(e) } return !0 } r = r.parentElement } return !1 }, Fn = function (e, r) { return !(r.disabled || Qa(r) || nl(r, e.displayCheck) || Ja(r) || ol(r)) }, ms = function (e, r) { return !(!Fn(e, r) || il(r) || fs(r) < 0) }, gs = function (e, r) { r = r || {}; var i = [], o = [], s = ps(e, r.includeContainer, ms.bind(null, r)); s.forEach(function (a, c) { var u = fs(a); u === 0 ? i.push(a) : o.push({ documentOrder: c, tabIndex: u, node: a }) }); var l = o.sort(Za).map(function (a) { return a.node }).concat(i); return l }, vs = function (e, r) { r = r || {}; var i = ps(e, r.includeContainer, Fn.bind(null, r)); return i }, Jt = function (e, r) { if (r = r || {}, !e) throw new Error("No node provided"); return Qt.call(e, Hn) === !1 ? !1 : ms(r, e) }, sl = hs.concat("iframe").join(","), Di = function (e, r) { if (r = r || {}, !e) throw new Error("No node provided"); return Qt.call(e, sl) === !1 ? !1 : Fn(r, e) }; function bs(t, e) { var r = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter(function (o) { return Object.getOwnPropertyDescriptor(t, o).enumerable })), r.push.apply(r, i) } return r } function al(t) { for (var e = 1; e < arguments.length; e++) { var r = arguments[e] != null ? arguments[e] : {}; e % 2 ? bs(Object(r), !0).forEach(function (i) { ll(t, i, r[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : bs(Object(r)).forEach(function (i) { Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i)) }) } return t } function ll(t, e, r) { return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t } var ys = function () { var t = []; return { activateTrap: function (r) { if (t.length > 0) { var i = t[t.length - 1]; i !== r && i.pause() } var o = t.indexOf(r); o === -1 || t.splice(o, 1), t.push(r) }, deactivateTrap: function (r) { var i = t.indexOf(r); i !== -1 && t.splice(i, 1), t.length > 0 && t[t.length - 1].unpause() } } }(), cl = function (e) { return e.tagName && e.tagName.toLowerCase() === "input" && typeof e.select == "function" }, dl = function (e) { return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27 }, ul = function (e) { return e.key === "Tab" || e.keyCode === 9 }, xs = function (e) { return setTimeout(e, 0) }, Nn = function (e, r) { var i = -1; return e.every(function (o, s) { return r(o) ? (i = s, !1) : !0 }), i }, er = function (e) { for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)i[o - 1] = arguments[o]; return typeof e == "function" ? e.apply(void 0, i) : e }, ji = function (e) { return e.target.shadowRoot && typeof e.composedPath == "function" ? e.composedPath()[0] : e.target }, As = function (e, r) { var i = (r == null ? void 0 : r.document) || document, o = al({ returnFocusOnDeactivate: !0, escapeDeactivates: !0, delayInitialFocus: !0 }, r), s = { containers: [], tabbableGroups: [], nodeFocusedBeforeActivation: null, mostRecentlyFocusedNode: null, active: !1, paused: !1, delayInitialFocusTimer: void 0 }, l, a = function (m, g, E) { return m && m[g] !== void 0 ? m[g] : o[E || g] }, c = function (m) { return !!(m && s.containers.some(function (g) { return g.contains(m) })) }, u = function (m) { var g = o[m]; if (typeof g == "function") { for (var E = arguments.length, L = new Array(E > 1 ? E - 1 : 0), k = 1; k < E; k++)L[k - 1] = arguments[k]; g = g.apply(void 0, L) } if (!g) { if (g === void 0 || g === !1) return g; throw new Error("`".concat(m, "` was specified but was not a node, or did not return a node")) } var P = g; if (typeof g == "string" && (P = i.querySelector(g), !P)) throw new Error("`".concat(m, "` as selector refers to no known node")); return P }, h = function () { var m = u("initialFocus"); if (m === !1) return !1; if (m === void 0) if (c(i.activeElement)) m = i.activeElement; else { var g = s.tabbableGroups[0], E = g && g.firstTabbableNode; m = E || u("fallbackFocus") } if (!m) throw new Error("Your focus-trap needs to have at least one focusable element"); return m }, f = function () { if (s.tabbableGroups = s.containers.map(function (m) { var g = gs(m), E = vs(m); if (g.length > 0) return { container: m, firstTabbableNode: g[0], lastTabbableNode: g[g.length - 1], nextTabbableNode: function (k) { var P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Ce = E.findIndex(function (Q) { return Q === k }); return P ? E.slice(Ce + 1).find(function (Q) { return Jt(Q) }) : E.slice(0, Ce).reverse().find(function (Q) { return Jt(Q) }) } } }).filter(function (m) { return !!m }), s.tabbableGroups.length <= 0 && !u("fallbackFocus")) throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times") }, b = function O(m) { if (m !== !1 && m !== i.activeElement) { if (!m || !m.focus) { O(h()); return } m.focus({ preventScroll: !!o.preventScroll }), s.mostRecentlyFocusedNode = m, cl(m) && m.select() } }, A = function (m) { var g = u("setReturnFocus", m); return g || (g === !1 ? !1 : m) }, v = function (m) { var g = ji(m); if (!c(g)) { if (er(o.clickOutsideDeactivates, m)) { l.deactivate({ returnFocus: o.returnFocusOnDeactivate && !Di(g) }); return } er(o.allowOutsideClick, m) || m.preventDefault() } }, y = function (m) { var g = ji(m), E = c(g); E || g instanceof Document ? E && (s.mostRecentlyFocusedNode = g) : (m.stopImmediatePropagation(), b(s.mostRecentlyFocusedNode || h())) }, S = function (m) { var g = ji(m); f(); var E = null; if (s.tabbableGroups.length > 0) { var L = Nn(s.tabbableGroups, function (kt) { var It = kt.container; return It.contains(g) }), k = L >= 0 ? s.tabbableGroups[L] : void 0; if (L < 0) m.shiftKey ? E = s.tabbableGroups[s.tabbableGroups.length - 1].lastTabbableNode : E = s.tabbableGroups[0].firstTabbableNode; else if (m.shiftKey) { var P = Nn(s.tabbableGroups, function (kt) { var It = kt.firstTabbableNode; return g === It }); if (P < 0 && (k.container === g || Di(g) && !Jt(g) && !k.nextTabbableNode(g, !1)) && (P = L), P >= 0) { var Ce = P === 0 ? s.tabbableGroups.length - 1 : P - 1, Q = s.tabbableGroups[Ce]; E = Q.lastTabbableNode } } else { var ne = Nn(s.tabbableGroups, function (kt) { var It = kt.lastTabbableNode; return g === It }); if (ne < 0 && (k.container === g || Di(g) && !Jt(g) && !k.nextTabbableNode(g)) && (ne = L), ne >= 0) { var nn = ne === s.tabbableGroups.length - 1 ? 0 : ne + 1, Ds = s.tabbableGroups[nn]; E = Ds.firstTabbableNode } } } else E = u("fallbackFocus"); E && (m.preventDefault(), b(E)) }, T = function (m) { if (dl(m) && er(o.escapeDeactivates, m) !== !1) { m.preventDefault(), l.deactivate(); return } if (ul(m)) { S(m); return } }, D = function (m) { if (!er(o.clickOutsideDeactivates, m)) { var g = ji(m); c(g) || er(o.allowOutsideClick, m) || (m.preventDefault(), m.stopImmediatePropagation()) } }, B = function () { if (!!s.active) return ys.activateTrap(l), s.delayInitialFocusTimer = o.delayInitialFocus ? xs(function () { b(h()) }) : b(h()), i.addEventListener("focusin", y, !0), i.addEventListener("mousedown", v, { capture: !0, passive: !1 }), i.addEventListener("touchstart", v, { capture: !0, passive: !1 }), i.addEventListener("click", D, { capture: !0, passive: !1 }), i.addEventListener("keydown", T, { capture: !0, passive: !1 }), l }, He = function () { if (!!s.active) return i.removeEventListener("focusin", y, !0), i.removeEventListener("mousedown", v, !0), i.removeEventListener("touchstart", v, !0), i.removeEventListener("click", D, !0), i.removeEventListener("keydown", T, !0), l }; return l = { activate: function (m) { if (s.active) return this; var g = a(m, "onActivate"), E = a(m, "onPostActivate"), L = a(m, "checkCanFocusTrap"); L || f(), s.active = !0, s.paused = !1, s.nodeFocusedBeforeActivation = i.activeElement, g && g(); var k = function () { L && f(), B(), E && E() }; return L ? (L(s.containers.concat()).then(k, k), this) : (k(), this) }, deactivate: function (m) { if (!s.active) return this; clearTimeout(s.delayInitialFocusTimer), s.delayInitialFocusTimer = void 0, He(), s.active = !1, s.paused = !1, ys.deactivateTrap(l); var g = a(m, "onDeactivate"), E = a(m, "onPostDeactivate"), L = a(m, "checkCanReturnFocus"); g && g(); var k = a(m, "returnFocus", "returnFocusOnDeactivate"), P = function () { xs(function () { k && b(A(s.nodeFocusedBeforeActivation)), E && E() }) }; return k && L ? (L(A(s.nodeFocusedBeforeActivation)).then(P, P), this) : (P(), this) }, pause: function () { return s.paused || !s.active ? this : (s.paused = !0, He(), this) }, unpause: function () { return !s.paused || !s.active ? this : (s.paused = !1, f(), B(), this) }, updateContainerElements: function (m) { var g = [].concat(m).filter(Boolean); return s.containers = g.map(function (E) { return typeof E == "string" ? i.querySelector(E) : E }), s.active && f(), this } }, l.updateContainerElements(e), l }; var Es = class { constructor() { this.feedbackEnabled = !0; this.autofillSessionToken = new ee; this.autofillSessionEnabled = !1; this.detectBrowserAutofillEnabled = !1 } }, R = new Es; Object.defineProperty(R, "autofillSessionToken", { configurable: !1, writable: !1 }); var hl = j(`
<template>
  <div class="MapboxAddressConfirmation" aria-hidden="true">
    <mapbox-address-confirmation-feature class="ContentFeature"></mapbox-address-confirmation-feature>
    <mapbox-address-confirmation-no-feature class="ContentNoFeature"></mapbox-address-confirmation-no-feature>
  </div>
</template>
`), tr, K, Ge, rr, Ve = class extends W { constructor() { super(...arguments); d(this, tr, !1); d(this, K, void 0); d(this, Ge, void 0); d(this, rr, {}) } get template() { return hl } get templateStyle() { return te } get templateUserStyle() { return $(".MapboxAddressConfirmation", this.theme) } get theme() { return n(this, rr) } set theme(e) { if (p(this, rr, e), !n(this, K) || !e) return; this.updateTemplateUserStyle($(".MapboxAddressConfirmation", e)); let { ContentFeature: r, ContentNoFeature: i } = n(this, K); r.theme = e, i.theme = e } connectedCallback() { super.connectedCallback(), p(this, K, J(this, { MapboxAddressConfirmation: ".MapboxAddressConfirmation", ContentFeature: ".ContentFeature", ContentNoFeature: ".ContentNoFeature" })); let { MapboxAddressConfirmation: e } = n(this, K); e.setAttribute("aria-hidden", "true"); let r = this.theme; if (r) { let { ContentFeature: i, ContentNoFeature: o } = n(this, K); i.theme = r, o.theme = r } } disconnectedCallback() { p(this, Ge, null) } hide() { var r; if (p(this, tr, !1), !n(this, K)) return; let { MapboxAddressConfirmation: e } = n(this, K); e.setAttribute("aria-hidden", "true"), (r = n(this, Ge)) == null || r.deactivate(), Dn.default.off() } show(e, r, i) { return F(this, null, function* () { var b; if (!n(this, K)) return { type: "cancel" }; let { MapboxAddressConfirmation: o, ContentFeature: s, ContentNoFeature: l } = n(this, K), { accessToken: a, minimap: c = !1, theme: u, footer: h } = r; this.theme = u, i ? (s.removeAttribute("aria-hidden"), l.setAttribute("aria-hidden", "true"), s.minimap = c, s.accessToken = a, s.footer = h, s.update(i, e)) : (s.setAttribute("aria-hidden", "true"), l.removeAttribute("aria-hidden"), l.update(e)), p(this, tr, !0), o.removeAttribute("aria-hidden"), Dn.default.on(); let f = i ? s : l; return p(this, Ge, As(o, { fallbackFocus: f, escapeDeactivates: () => (this.hide(), !0) })), (b = n(this, Ge)) == null || b.activate(), new Promise(A => { let v = f, y = S => { v.removeEventListener("result", y); let T = S.detail; this.hide(), A(T === "change" ? { type: "change", feature: i } : { type: T }) }; v.addEventListener("result", y) }) }) } tryShow(e, r) { return F(this, null, function* () { if (!n(this, K)) return { type: "cancel" }; let { accessToken: i, options: o = {} } = r, s = new bn(x({ accessToken: i }, o)), l = pt(e), c = (yield s.validate(l, { sessionToken: R.autofillSessionToken })).features[0]; if (c) { let u = f => f.properties.match_code.confidence === yn.exact, { skipConfirmModal: h = u } = r; if (h(c)) return { type: "nochange" } } return yield this.show(e, r, c) }) } }; tr = new WeakMap, K = new WeakMap, Ge = new WeakMap, rr = new WeakMap; window.MapboxAddressConfirmation = Ve; window.customElements.get("mapbox-address-confirmation") || customElements.define("mapbox-address-confirmation", Ve); var jn = new Ve; function $i(r) { return F(this, arguments, function* (t, e = {}) { let { sections: i = [] } = e; jn.parentNode || document.body.appendChild(jn); let o = { type: "nochange" }, s = Xt(t), l = qt(t), a = Array.from(document.querySelectorAll("mapbox-search-listbox")); for (let c of s) { if (i.length) { let v = l.find(y => y.input === c); if (!v || !i.includes(v.section)) continue } let u = Hi(t, c), h = a.find(v => v.input === c), f = h == null ? void 0 : h.autofillHost; if (f) { let v = f.retrieveFeature; if (v) { let y = ls(v); if (!cs(u, y)) continue } } let b = e.accessToken || R.accessToken, A = yield jn.tryShow(u, z(x({}, e), { accessToken: b })); if (A.type === "change") if (h) f.simulateRetrieve(A.feature); else { c.dataset.mapboxSuccess = "true"; let v = nt(A.feature); Pn(t, c, v) } A.type === "change" && o.type !== "cancel" && (o = A), A.type === "cancel" && (o = A) } return o }) } function Ui(t, e) {
    if (e) {
      let r = j(`
        <span>
          <span></span>
          <br />
          <span></span>
        </span>
      `), [i, o] = Array.from(r.querySelectorAll("span > span")), s = e.split(","); if (i.textContent = s[0].trim(), o.textContent = s.slice(1).join(",").trim(), t["address-line2"]) { let l = document.createElement("span"); l.textContent = t["address-line2"], r.insertBefore(l, o), r.insertBefore(document.createElement("br"), o) } if (t["address-line3"]) { let l = document.createElement("span"); l.textContent = t["address-line3"], r.insertBefore(l, o), r.insertBefore(document.createElement("br"), o) } return r
    } else {
      let r = t["street-address"] || t["address-line1"] || "", i = t["address-line2"], o = t["address-line3"], s = [t["address-level4"] || "", t["address-level3"] || "", t["address-level2"] || "", `${t["address-level1"] || ""} ${t["postal-code"] || ""}`, t.country || t["country-name"] || ""].filter(Boolean).join(", "), a = [r, i, o, s].filter(Boolean).map(u => `<span>${u}</span>`).join("<br />"); return j(`
        <span>${a}</span>
      `)
    }
  } function zi(t, e, r, i) { return F(this, null, function* () { if (!r) return; let o = On(t), s = Object.values(Kt(o, t)); if (!e.detail.elements.some(b => s.includes(b))) return; let l = qt(o), c = l.find(b => b.input === t).section, u = Array.from(new Set(l.filter(b => e.detail.elements.includes(b.input)).map(b => b.section))); if (!u.includes(c)) return; let h = typeof r == "object" && r.sections || []; if (h.length && !h.some(b => u.includes(b))) return; let f = typeof r == "object" ? r : {}; f = z(x({}, f), { accessToken: i, sections: [c] }), yield $i(o, f) }) } var pl = "https://contribute-api.mapbox.com/v1", fl = "https://contribute-api-staging.tilestream.net/v1", ml = "edit-suggestion"; function Gi(t, e) { if (!R.feedbackEnabled) return; let r = window.location.hostname, o = `${Lo(r) || Co(r) ? fl : pl}/${ml}/address?access_token=${t}`, { originalCoordinate: s, originalAddress: l, changes: a } = e, c = { action: "update", reason: "incorrect_address", location: { longitude: s[0], latitude: s[1] }, userEmail: "no-reply-autofill@mapbox.com", changes: a, placeName: l }; fetch(o, { method: "POST", headers: new Headers({ "User-Agent": `mapbox-search-js.${_t}.${navigator.userAgent}`, "Content-Type": "application/json" }), body: JSON.stringify(c) }) } var gl = j(`
<template>
  <div class="MapboxAddressConfirmationFeature">
    <div class="Modal" aria-modal="true" role="dialog">
      <div class="ModalHeader">
        <svg viewBox="0 0 18 18" class="Icon IconQuestion"></svg>
        <div class="ModalHeaderTitle">Did you mean?</div>
        <svg
          viewBox="0 0 18 18"
          class="Icon IconClose"
          tabindex="0"
          role="button"
          title="Close"
          aria-label="Close"
          aria-expanded="true"
        ></svg>
      </div>

      <div class="ModalAddress ModalAddressApprove"></div>
            
      <div class="ModalMap">
        <mapbox-address-minimap class="Minimap"></mapbox-address-minimap>
      </div>

      <div
        class="Button ButtonPrimary ButtonApprove"
        tabindex="0"
        role="button"
        aria-label="Yes"
      >
        Yes
      </div>
      
      <div
        class="Button ButtonSecondary ButtonReject"
        tabindex="0"
        role="button"
        aria-label="No, use the address I provided"
      >
        No, use the address I provided
      </div>

      <div class="ModalFooter">
          Your confirmation helps improve address data accuracy.
      </div>
    </div>
  </div>
</template>
`), ge, ir, ft, nr, or, sr, ar, lr, $n = class extends W { constructor() { super(...arguments); d(this, ge, void 0); d(this, ir, {}); this.minimap = !1; d(this, ft, void 0); d(this, nr, void 0); this.update = (e, r) => { p(this, ft, e), p(this, nr, r); let { ModalMap: i, Minimap: o, ModalAddressApprove: s } = n(this, ge); if (this.minimap) { if (i.removeAttribute("aria-hidden"), o.accessToken = this.accessToken, typeof this.minimap == "object") { let { defaultMapStyle: a, theme: c, mapStyleMode: u, satelliteToggle: h } = this.minimap; a && (o.defaultMapStyle = this.minimap.defaultMapStyle), c && (o.theme = this.minimap.theme), u && (o.mapStyleMode = u), h !== void 0 && (o.satelliteToggle = h) } o.feature = e } else i.setAttribute("aria-hidden", "true"); let l = e.properties.place_name || e.properties.full_address || e.properties.address; s.innerHTML = "", s.appendChild(Ui(r, l)) }; d(this, or, () => { this.dispatchEvent(new M("result", "cancel")) }); this.approve = () => { this.dispatchEvent(new M("result", "change")) }; this.reject = () => { this.dispatchEvent(new M("result", "nochange")), Gi(this.accessToken, { originalCoordinate: n(this, ft).geometry.coordinates, originalAddress: n(this, ft).properties.full_address, changes: { address: pt(n(this, nr)) } }) }; d(this, sr, pe()); d(this, ar, pe()); d(this, lr, pe()) } get template() { return gl } get templateStyle() { return te } get templateUserStyle() { return $(".MapboxAddressConfirmationFeature", this.theme) } get theme() { return n(this, ir) } set theme(e) { if (p(this, ir, e), !n(this, ge) || !e) return; this.updateTemplateUserStyle($(".MapboxAddressConfirmationFeature", e)); let { IconQuestion: r, IconClose: i } = n(this, ge); r.innerHTML = V("question", e), i.innerHTML = V("close", e) } set footer(e) { if (e === void 0) return; let r = this.querySelector(".ModalFooter"); typeof e == "string" ? (r.textContent = e, r.removeAttribute("aria-hidden")) : e ? r.removeAttribute("aria-hidden") : r.setAttribute("aria-hidden", "true") } connectedCallback() { super.connectedCallback(), p(this, ge, J(this, { MapboxAddressConfirmationFeature: ".MapboxAddressConfirmationFeature", Modal: ".Modal", ModalHeaderTitle: ".ModalHeaderTitle", ModalMap: ".ModalMap", Minimap: ".Minimap", IconQuestion: ".IconQuestion", IconClose: ".IconClose", ButtonApprove: ".ButtonApprove", ButtonReject: ".ButtonReject", ModalAddressApprove: ".ModalAddressApprove" })); let { Modal: e, ModalHeaderTitle: r, IconClose: i, ButtonApprove: o, ButtonReject: s, ModalAddressApprove: l } = n(this, ge); e.setAttribute("aria-labelledby", n(this, ar)), e.setAttribute("aria-describedby", n(this, lr)), i.setAttribute("aria-controls", n(this, sr)), e.id = n(this, sr), r.id = n(this, ar), l.id = n(this, lr); let a = Array.from(this.querySelectorAll('[role="button"]')); for (let u of a) u.addEventListener("keydown", Bi); i.addEventListener("click", n(this, or)), o.addEventListener("click", this.approve), s.addEventListener("click", this.reject); let c = this.theme; if (c) { let { IconQuestion: u, IconClose: h } = n(this, ge); u.innerHTML = V("question", c), h.innerHTML = V("close", c) } } disconnectedCallback() { let { IconClose: e, ButtonApprove: r } = n(this, ge); e.removeEventListener("click", n(this, or)), r.removeEventListener("click", this.approve) } }; ge = new WeakMap, ir = new WeakMap, ft = new WeakMap, nr = new WeakMap, or = new WeakMap, sr = new WeakMap, ar = new WeakMap, lr = new WeakMap; window.MapboxAddressConfirmationFeature = $n; window.customElements.get("mapbox-address-confirmation-feature") || customElements.define("mapbox-address-confirmation-feature", $n); var vl = j(`
<template>
  <div class="MapboxAddressConfirmationNoFeature">
    <div class="Modal" aria-modal="true" role="dialog">
      <div class="ModalHeader">
        <svg viewBox="0 0 18 18" class="Icon IconQuestion"></svg>
        <div class="ModalHeaderTitle">Confirm address</div>
        <svg
          viewBox="0 0 18 18"
          class="Icon IconClose"
          tabindex="0"
          role="button"
          title="Close"
          aria-label="Close"
          aria-expanded="true"
        ></svg>
      </div>
      <div class="ModalDescription">
        We couldn't verify this address. Please check that your information is correct before continuing.
      </div>
      <br />
      <div class="ModalSubheader">
        You entered
      </div>
      <div class="ModalAddress"></div>
      <div
        class="Button ButtonPrimary"
        tabindex="0"
        role="button"
        aria-label="Use the address I provided"
      >
        Use the address I provided
      </div>
    </div>
  </div>
</template>
`), ve, cr, dr, ur, hr, pr, Un = class extends W { constructor() { super(...arguments); d(this, ve, void 0); d(this, cr, {}); this.update = e => { let { ModalAddress: r } = n(this, ve); r.innerHTML = "", r.appendChild(Ui(e)) }; d(this, dr, () => { this.dispatchEvent(new M("result", "cancel")) }); this.reject = () => { this.dispatchEvent(new M("result", "nochange")) }; d(this, ur, pe()); d(this, hr, pe()); d(this, pr, pe()) } get template() { return vl } get templateStyle() { return te } get templateUserStyle() { return $(".MapboxAddressConfirmationNoFeature", this.theme) } get theme() { return n(this, cr) } set theme(e) { if (p(this, cr, e), !n(this, ve) || !e) return; this.updateTemplateUserStyle($(".MapboxAddressConfirmationNoFeature", e)); let { IconQuestion: r, IconClose: i } = n(this, ve); r.innerHTML = V("question", e), i.innerHTML = V("close", e) } connectedCallback() { super.connectedCallback(), p(this, ve, J(this, { Modal: ".Modal", ModalHeaderTitle: ".ModalHeaderTitle", IconQuestion: ".IconQuestion", IconClose: ".IconClose", ModalAddress: ".ModalAddress", ButtonReject: ".Button" })); let { Modal: e, ModalHeaderTitle: r, IconClose: i, ModalAddress: o, ButtonReject: s } = n(this, ve); e.setAttribute("aria-labelledby", n(this, hr)), e.setAttribute("aria-describedby", n(this, pr)), i.setAttribute("aria-controls", n(this, ur)), e.id = n(this, ur), r.id = n(this, hr), o.id = n(this, pr); let l = Array.from(this.querySelectorAll('[role="button"]')); for (let c of l) c.addEventListener("keydown", Bi); i.addEventListener("click", n(this, dr)), s.addEventListener("click", this.reject); let a = this.theme; if (a) { let { IconQuestion: c, IconClose: u } = n(this, ve); c.innerHTML = V("question", a), u.innerHTML = V("close", a) } } disconnectedCallback() { let { IconClose: e, ButtonReject: r } = n(this, ve); e.removeEventListener("click", n(this, dr)), r.removeEventListener("click", this.reject) } }; ve = new WeakMap, cr = new WeakMap, dr = new WeakMap, ur = new WeakMap, hr = new WeakMap, pr = new WeakMap; window.MapboxAddressConfirmationNoFeature = Un; window.customElements.get("mapbox-address-confirmation-no-feature") || customElements.define("mapbox-address-confirmation-no-feature", Un); var Ss = 'input:-webkit-autofill,select:-webkit-autofill,textarea:-webkit-autofill{animation-name:onbrowserautofillstart}input:not(:-webkit-autofill),select:not(:-webkit-autofill),textarea:not(:-webkit-autofill){animation-name:onbrowserautofillcancel}@keyframes onbrowserautofillstart{0%{animation-name:"onbrowserautofillstart"}to{animation-name:"onbrowserautofillstart"}}@keyframes onbrowserautofillcancel{0%{animation-name:"onbrowserautofillcancel"}to{animation-name:"onbrowserautofillcancel"}}'; var Vi = "browser-autofilled", zn = []; function yl() { window.dispatchEvent(new window.CustomEvent("browserautofill", { bubbles: !0, cancelable: !0, detail: { elements: zn } })), zn = [] } var xl = An(yl, 5); function Ms(t) { t.hasAttribute(Vi) || (t.setAttribute(Vi, ""), zn.push(t), xl()) } function Ts(t) { !t.hasAttribute(Vi) || t.removeAttribute(Vi) } function Al(t) { t.animationName === "onbrowserautofillstart" ? Ms(t.target) : Ts(t.target) } function El(t) { let e = t.target; e.nodeName.toLowerCase() !== "select" && !t.simulated && !(t instanceof M) && (t.inputType === "insertReplacementText" || !("data" in t)) ? Ms(e) : Ts(e) } function Yi() { R.detectBrowserAutofillEnabled || (R.detectBrowserAutofillEnabled = !0, oo(Ss), document.addEventListener("animationstart", Al, !0), document.addEventListener("input", El, !0)) } var Ye, Z, X, w, Me, mt, fr, mr, gt, gr, vr, br, yr, xr, Ar, Er, vt = class extends W { constructor() { super(...arguments); d(this, Ye, new Ht); d(this, Z, new it(n(this, Ye))); d(this, X, void 0); d(this, w, new Se); d(this, Me, void 0); this.options = {}; this.confirmOnBrowserAutofill = !1; d(this, mt, !1); d(this, fr, e => { let r = (e == null ? void 0 : e.suggestions) ? _i(e.suggestions) : null; n(this, w).handleSuggest(r), this.dispatchEvent(new M("suggest", e)) }); d(this, mr, e => { n(this, w).handleError(), this.dispatchEvent(new M("suggesterror", e)) }); d(this, gt, e => { var i; if (this.dispatchEvent(new M("retrieve", e)), this.retrieveFeature = (i = e.features) == null ? void 0 : i[0], !n(this, X)) return; let r = e; !r || !r.features || !r.features.length || Zt(r.features[0], n(this, X)) }); d(this, gr, () => { var e; try { let r = (e = this.querySelector("input")) != null ? e : null; p(this, X, r), n(this, w).input = r } catch (r) { p(this, X, null), n(this, w).input = null, console.error(r.message || r) } }); d(this, vr, new MutationObserver(n(this, gr))); d(this, br, e => { n(this, w).blur(), zi(n(this, X), e, this.confirmOnBrowserAutofill, this.accessToken) }); this.retrieveFeature = null; this.interceptSearch = null; d(this, yr, e => { this.dispatchEvent(e.clone()); let r = e.detail, i = this.browserAutofillEnabled === !0 && (r == null ? void 0 : r.length) <= 2; re(n(this, X), n(this, Me), i); let o = this.interceptSearch && this.interceptSearch(r), s = this.interceptSearch ? o : r; if (this.interceptSearch && !o || (s == null ? void 0 : s.length) <= 2) { n(this, w).handleSuggest(null); return } n(this, Z).suggest(s, this.options) }); d(this, xr, e => { let r = e.detail; e.detail.accuracy !== "street" ? (re(n(this, X), n(this, Me), !0), n(this, Z).retrieve(r, this.options)) : Fi(n(this, X), n(this, Me), r) }); d(this, Ar, () => { re(n(this, X), n(this, Me), !0), n(this, Z).abort() }); d(this, Er, () => { var r; let e = this.browserAutofillEnabled === !0 && ((r = n(this, X).value) == null ? void 0 : r.length) <= 2; re(n(this, X), n(this, Me), e) }) } get accessToken() { return n(this, Ye).accessToken } set accessToken(e) { n(this, Ye).accessToken = e } get input() { return n(this, X) } get theme() { return n(this, w).theme } set theme(e) { n(this, w).theme = e } get popoverOptions() { return n(this, w).popoverOptions } set popoverOptions(e) { n(this, w).popoverOptions = e } get browserAutofillEnabled() { return n(this, mt) } set browserAutofillEnabled(e) { p(this, mt, e) } connectedCallback() { var r; super.connectedCallback(), R.autofillSessionEnabled = !0, n(this, Z).sessionToken = R.autofillSessionToken, n(this, w).autofillHost = this, n(this, w).searchService = 0; let e = (r = this.querySelector("input")) != null ? r : null; n(this, vr).observe(this, { subtree: !0, childList: !0 }), n(this, gr).call(this), n(this, w).addEventListener("input", n(this, yr)), n(this, w).addEventListener("select", n(this, xr)), n(this, w).addEventListener("blur", n(this, Ar)), n(this, w).addEventListener("focus", n(this, Er)), n(this, Z).addEventListener("suggest", n(this, fr)), n(this, Z).addEventListener("suggesterror", n(this, mr)), n(this, Z).addEventListener("retrieve", n(this, gt)), document.body.appendChild(n(this, w)), e && (e.insertAdjacentElement("beforebegin", at(n(this, w).dataSeed)), Oi(e), p(this, Me, e.autocomplete)), Yi(), window.addEventListener("browserautofill", n(this, br)) } disconnectedCallback() { n(this, w).remove(), n(this, w).removeEventListener("input", n(this, yr)), n(this, w).removeEventListener("select", n(this, xr)), n(this, w).removeEventListener("blur", n(this, Ar)), n(this, w).removeEventListener("focus", n(this, Er)), n(this, Z).removeEventListener("suggest", n(this, fr)), n(this, Z).removeEventListener("suggesterror", n(this, mr)), n(this, Z).removeEventListener("retrieve", n(this, gt)), n(this, vr).disconnect(), window.removeEventListener("browserautofill", n(this, br)) } attributeChangedCallback(e, r, i) { if (e === "access-token") { n(this, Ye).accessToken = i; return } if (e === "browser-autofill-enabled") { p(this, mt, Boolean(i)); return } if (e === "theme") { this.theme = ot(i); return } if (e === "popover-options") { this.popoverOptions = ot(i); return } let o = e.split("-").join("_"); i || delete this.options[o], this.options[o] = i } focus() { n(this, w).focus() } simulateRetrieve(e) { let r = this.input; r && (r.dataset.mapboxSuccess = "true"), n(this, w).hideResults(); let i = { type: "FeatureCollection", features: [e], url: "" }; n(this, gt).call(this, i) } }; Ye = new WeakMap, Z = new WeakMap, X = new WeakMap, w = new WeakMap, Me = new WeakMap, mt = new WeakMap, fr = new WeakMap, mr = new WeakMap, gt = new WeakMap, gr = new WeakMap, vr = new WeakMap, br = new WeakMap, yr = new WeakMap, xr = new WeakMap, Ar = new WeakMap, Er = new WeakMap, vt.observedAttributes = ["access-token", "browser-autofill-enabled", "theme", "popover-options", "css-text", "language", "country", "bbox", "limit", "proximity"]; window.MapboxAddressAutofill = vt; window.customElements.get("mapbox-address-autofill") || customElements.define("mapbox-address-autofill", vt); var ks = an(Ls()); var Sl = { de: "Suche", it: "Ricerca", en: "Search", nl: "Zoeken", fr: "Chercher", ca: "Cerca", he: "\u05DC\u05D7\u05E4\u05E9", ja: "\u30B5\u30FC\u30C1", lv: "Mekl\u0113t", pt: "Procurar", sr: "\u041F\u0440\u0435\u0442\u0440\u0430\u0433\u0430", zh: "\u641C\u7D22", cs: "Vyhled\xE1v\xE1n\xED", hu: "Keres\xE9s", ka: "\u10EB\u10D8\u10D4\u10D1\u10D0", nb: "S\xF8ke", sk: "Vyh\u013Ead\xE1vanie", th: "\u0E04\u0E49\u0E19\u0E2B\u0E32", fi: "Hae", is: "Leita", ko: "\uC218\uC0C9", pl: "Szukaj", sl: "Iskanje", fa: "\u062C\u0633\u062A\u062C\u0648", ru: "\u041F\u043E\u0438\u0441\u043A" }, Cs = { placeholder: Sl }; var Ml = 9, oe, We, ie, be, se, I, Xi, Tl, Xe, Sr, Mr, Tr, Oe, wr, Lr, bt, Cr, kr, Te, Ir, Rr, yt = class extends W { constructor() { super(...arguments); d(this, Xi); d(this, oe, void 0); d(this, We, new vn({})); d(this, ie, new it(n(this, We))); d(this, be, null); d(this, se, void 0); d(this, I, new Se); this.options = {}; d(this, Xe, void 0); d(this, Sr, e => { n(this, Te).call(this), n(this, I).handleSuggest((e == null ? void 0 : e.suggestions) || null), this.dispatchEvent(new M("suggest", e)) }); d(this, Mr, e => { n(this, Te).call(this), n(this, I).handleError(), this.dispatchEvent(new M("suggesterror", e)) }); d(this, Tr, e => { n(this, Te).call(this), this.dispatchEvent(new M("retrieve", e)); let r = e; if (!r || !r.features.length) return; let i = nt(r.features[0]); n(this, se).value = i.name; let o = n(this, be); if (!o) return; let s = r.features[0]; if (!s) return; let l = s.properties.feature_type, a = s.properties.bbox; if (a) o.flyTo(bo(o, he.convert(a).toFlatArray())); else { let c = s.geometry.coordinates, u = yo(l); o.flyTo({ center: c, zoom: u, speed: En }) } this.marker && this.mapboxgl && n(this, Lr).call(this, s) }); d(this, Oe, void 0); d(this, wr, () => { n(this, Oe) && (n(this, Oe).remove(), p(this, Oe, null)) }); d(this, Lr, e => { if (!n(this, be) || (n(this, wr).call(this), !e)) return; let i = x(x({}, { color: "#4668F2" }), typeof this.marker == "object" && this.marker); p(this, Oe, new this.mapboxgl.Marker(i)), e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && n(this, Oe).setLngLat(e.geometry.coordinates).addTo(n(this, be)) }); this.interceptSearch = null; d(this, bt, e => { this.dispatchEvent(e.clone()); let r = e.detail; if (!r) { n(this, Ir).call(this); return } let i = this.interceptSearch && this.interceptSearch(r), o = this.interceptSearch ? i : r; if (this.interceptSearch && !i) { n(this, I).hideResults(); return } n(this, ie).suggest(o, this.options), n(this, Te).call(this, !0) }); d(this, Cr, e => { let r = e.detail; n(this, ie).retrieve(r, this.options), n(this, Te).call(this, !0) }); d(this, kr, () => { n(this, ie).abort() }); d(this, Te, (e = !1) => { e ? (n(this, oe).ClearBtn.style.display = "none", n(this, oe).LoadingIcon.style.display = "block") : (n(this, oe).LoadingIcon.style.display = "none", n(this, oe).ClearBtn.style.display = this.value ? "block" : "none") }); d(this, Ir, () => { this.value = "", n(this, Te).call(this), n(this, Lr).call(this, null), n(this, I).handleSuggest(null) }); this.marker = !0; d(this, Rr, () => { let e = n(this, be), r = x({}, this.options); if (e.getZoom() <= Ml) { delete r.proximity, this.options = r; return } let i = e.getCenter(); this.options = z(x({}, r), { proximity: i }) }) } get accessToken() { return n(this, We).accessToken } set accessToken(e) { n(this, We).accessToken = e } get value() { return n(this, se).value } set value(e) { n(this, se).value = e } get input() { return n(this, se) } get template() { return wo } get templateStyle() { return te } get templateUserStyle() { return $(".SearchBox", n(this, I).theme) } get theme() { return n(this, I).theme } set theme(e) { if (n(this, I).theme = e, !n(this, oe) || !e) return; this.updateTemplateUserStyle($(".SearchBox", e)), n(this, I).updatePopover(); let { SearchIcon: r } = n(this, oe); r.innerHTML = V("search", e) } get popoverOptions() { return n(this, I).popoverOptions } set popoverOptions(e) { n(this, I).popoverOptions = e } get placeholder() { return n(this, Xe) || et(this, Xi, Tl).call(this) } set placeholder(e) { p(this, Xe, e), n(this, se) && (n(this, se).placeholder = this.placeholder, n(this, se).setAttribute("aria-label", this.placeholder)) } connectedCallback() { super.connectedCallback(), p(this, oe, J(this, { SearchBox: ".SearchBox", SearchIcon: ".SearchIcon", Input: ".Input", ClearBtn: ".ClearBtn", LoadingIcon: ".LoadingIcon" })), this.theme = x({}, this.theme); let { Input: e, ClearBtn: r } = n(this, oe); p(this, se, e), n(this, I).input = e, n(this, I).searchService = 3, n(this, I).addEventListener("input", n(this, bt)), n(this, I).addEventListener("select", n(this, Cr)), n(this, I).addEventListener("blur", n(this, kr)), n(this, ie).addEventListener("suggest", n(this, Sr)), n(this, ie).addEventListener("suggesterror", n(this, Mr)), n(this, ie).addEventListener("retrieve", n(this, Tr)), r.addEventListener("click", n(this, Ir)), this.placeholder = n(this, Xe), document.body.appendChild(n(this, I)), e && (e.previousElementSibling.hasAttribute("aria-live") && e.previousElementSibling.remove(), e.insertAdjacentElement("beforebegin", at(n(this, I).dataSeed))) } disconnectedCallback() { n(this, I).remove(), n(this, I).input = null, n(this, I).removeEventListener("input", n(this, bt)), n(this, I).removeEventListener("select", n(this, Cr)), n(this, I).removeEventListener("blur", n(this, kr)), n(this, ie).removeEventListener("suggest", n(this, Sr)), n(this, ie).removeEventListener("suggesterror", n(this, Mr)), n(this, ie).removeEventListener("retrieve", n(this, Tr)) } attributeChangedCallback(e, r, i) { if (e === "access-token") { n(this, We).accessToken = i; return } if (e === "theme") { this.theme = ot(i); return } if (e === "popover-options") { this.popoverOptions = ot(i); return } if (e === "placeholder") { this.placeholder = i; return } let o = e.split("-").join("_"); i || delete this.options[o], this.options[o] = i, o === "language" && (this.placeholder = n(this, Xe)) } focus() { n(this, I).focus() } search(e) { this.value = e, n(this, bt).call(this, new M("input", e)) } bindMap(e) { n(this, be) && n(this, be).off("moveend", n(this, Rr)), e && e.on("moveend", n(this, Rr)), p(this, be, e) } unbindMap() { this.bindMap(null) } onAdd(e) { this.bindMap(e), this.remove(); let r = document.createElement("div"); return r.className = "mapboxgl-ctrl", r.style.width = "300px", r.appendChild(this), r } onRemove() { this.remove(), this.unbindMap(), n(this, wr).call(this) } getDefaultPosition() { return "top-right" } }; oe = new WeakMap, We = new WeakMap, ie = new WeakMap, be = new WeakMap, se = new WeakMap, I = new WeakMap, Xi = new WeakSet, Tl = function () { if (this.options.language) { let e = this.options.language.split(",")[0], r = ks.default.language(e), i = Cs.placeholder[r]; if (i) return i } return "Search" }, Xe = new WeakMap, Sr = new WeakMap, Mr = new WeakMap, Tr = new WeakMap, Oe = new WeakMap, wr = new WeakMap, Lr = new WeakMap, bt = new WeakMap, Cr = new WeakMap, kr = new WeakMap, Te = new WeakMap, Ir = new WeakMap, Rr = new WeakMap, yt.observedAttributes = ["access-token", "theme", "popover-options", "placeholder", "language", "country", "bbox", "limit", "navigation-profile", "origin", "proximity", "eta-type", "types"]; window.MapboxSearchBox = yt; window.customElements.get("mapbox-search-box") || customElements.define("mapbox-search-box", yt); var Os = an(Is()); var Rs = new Os.default({ size: 512, antimeridian: !0 }), Ze = 1280; function Bs(t, e) { let { width: r, height: i } = gi(t, !0); switch (e) { case "center": return [0, 0]; case "top": return [0, i / 2]; case "bottom": return [0, -1 * i / 2]; case "left": return [r / 2, 0]; case "right": return [-1 * r / 2, 0]; case "top-left": return [r / 2, i / 2]; case "top-right": return [-1 * r / 2, i / 2]; case "bottom-left": return [r / 2, -1 * i / 2]; case "bottom-right": return [-1 * r / 2, -1 * i / 2] } } var Br, qi, qe, Or, Pr, Ki, Hr, _r, Zi, Fr, Nr, Ke, Qi, Dr, Yn = class { constructor(e, r, i, o, s, l) { d(this, Br, void 0); d(this, qi, () => { [this.anchorOffsetX, this.anchorOffsetY] = Bs(this.markerElement, this.anchor), this.markerTransform = { anchorX: this.anchorOffsetX, anchorY: this.anchorOffsetY } }); d(this, qe, { anchorX: 0, anchorY: 0, globalX: 0, globalY: 0, correctionX: 0, correctionY: 0 }); d(this, Or, !1); d(this, Pr, void 0); d(this, Ki, e => { !this.isActive || (e.preventDefault(), e.stopPropagation(), n(this, Ke).call(this, e), window.addEventListener("pointermove", n(this, _r)), window.addEventListener("pointerup", n(this, Hr))) }); d(this, Hr, () => { window.removeEventListener("pointermove", n(this, _r)), window.removeEventListener("pointerup", n(this, Hr)) }); d(this, _r, e => { e.preventDefault(), e.stopPropagation(); let r = this.curPointerXPos - e.pageX, i = this.curPointerYPos - e.pageY; this.markerDeltaX += r, this.markerDeltaY -= i, this.markerDeltaX = Math.max(Math.min(this.imgElement.width / 2, this.markerDeltaX), this.imgElement.width / 2 * -1), this.markerDeltaY = Math.max(Math.min(this.imgElement.height / 2, this.markerDeltaY), this.imgElement.height / 2 * -1); let o = this.imgCenterPx[0] - this.imgCenterAdjustedPx[0], s = this.imgCenterPx[1] - this.imgCenterAdjustedPx[1], l = this.markerDeltaX - o, a = this.markerDeltaY + s; this.markerTransform = { globalX: l, globalY: a }, n(this, Ke).call(this, e) }); d(this, Zi, e => { !this.isActive || (e.preventDefault(), e.stopPropagation(), n(this, Ke).call(this, e), window.addEventListener("pointermove", n(this, Nr)), window.addEventListener("pointerup", n(this, Fr))) }); d(this, Fr, () => { window.removeEventListener("pointermove", n(this, Nr)), window.removeEventListener("pointerup", n(this, Fr)) }); d(this, Nr, e => { e.preventDefault(); let r = Math.round(this.imgContainerElement.scrollTop + (this.curPointerYPos - e.pageY)); r = Math.max(Math.min(this.imgElement.height - this.imgContainerElement.clientHeight, r), 0); let i = Math.round(this.imgContainerElement.scrollLeft + (this.curPointerXPos - e.pageX)); i = Math.max(Math.min(this.imgElement.width - this.imgContainerElement.clientWidth, i), 0), this.imgContainerElement.scrollTop = r, this.imgContainerElement.scrollLeft = i; let o = Math.round(i - (this.imgElement.width - this.imgContainerElement.clientWidth) / 2), s = Math.round((this.imgElement.height - this.imgContainerElement.clientHeight) / 2 - r); if (this.imgCenterAdjustedPx = [this.imgCenterPx[0] + o, this.imgCenterPx[1] - s], !this.keepMarkerCentered) { let l = this.markerDeltaX + o, a = this.markerDeltaY + s; this.markerTransform = { globalX: l, globalY: a } } n(this, Dr).call(this, i, r), n(this, Ke).call(this, e) }); d(this, Ke, e => { this.curPointerXPos = e.pageX, this.curPointerYPos = e.pageY }); d(this, Qi, () => { let { anchorX: e, anchorY: r, globalX: i, globalY: o, correctionX: s, correctionY: l } = n(this, qe), a = e - i + s, c = r + o + l; this.markerElement.style.transform = `translate(calc(-50% + ${a}px), calc(-50% + ${c}px))` }); this.reCenter = () => { let e = (this.imgElement.height - this.imgContainerElement.clientHeight) / 2, r = (this.imgElement.width - this.imgContainerElement.clientWidth) / 2; this.imgContainerElement.scrollTop = e, this.imgContainerElement.scrollLeft = r, this.imgCenterAdjustedPx = this.imgCenterPx, this.markerDeltaX = this.markerDeltaY = 0, this.markerTransform = { globalX: 0, globalY: 0, correctionX: 0, correctionY: 0 } }; this.handleMinimapResize = () => { if (!this.imgElement.height || !this.imgElement.width) return; let e = this.imgCenterOffset.x, r = this.imgCenterOffset.y, i = this.imgElement.width / 2 - e - this.imgContainerElement.clientWidth / 2, o = this.imgElement.height / 2 - r - this.imgContainerElement.clientHeight / 2; this.imgContainerElement.scrollLeft = i, this.imgContainerElement.scrollTop = o, n(this, Dr).call(this, i, o) }; d(this, Dr, (e, r) => { let i = this.imgCenterOffset.x, o = this.imgCenterOffset.y, { correctionX: s, correctionY: l } = this.markerTransform, a = {}; if (e / 2 < i * -1) { let c = i * -1 - e / 2; a.correctionX = c * 2 } else e < 0 ? a.correctionX = e : s !== 0 && (a.correctionX = 0); if (r / 2 < o * -1) { let c = o * -1 - r / 2; a.correctionY = c * 2 } else r < 0 ? a.correctionY = r : l !== 0 && (a.correctionY = 0); this.markerTransform = a }); this.markerElement = i, this.imgContainerElement = e, this.imgElement = r, this.keepMarkerCentered = o, this.zoom = s, this.anchor = l, this.curPointerXPos = 0, this.curPointerYPos = 0, this.markerDeltaX = 0, this.markerDeltaY = 0, this.imgContainerElement.addEventListener("pointerdown", n(this, Zi)), this.keepMarkerCentered || this.markerElement.addEventListener("pointerdown", n(this, Ki)), new ResizeObserver(n(this, qi)).observe(this.markerElement) } get anchor() { return n(this, Br) } set anchor(e) { p(this, Br, e), [this.anchorOffsetX, this.anchorOffsetY] = Bs(this.markerElement, e), this.markerTransform = { anchorX: this.anchorOffsetX, anchorY: this.anchorOffsetY } } get markerTransform() { return n(this, qe) } set markerTransform(e) { p(this, qe, x(x({}, n(this, qe)), e)), n(this, Qi).call(this) } get isActive() { return n(this, Or) } set isActive(e) { this.imgContainerElement.style.touchAction = e ? "none" : "", p(this, Or, e) } get coordinate() { let e = this.keepMarkerCentered ? this.imgCenterAdjustedPx : [this.imgCenterPx[0] - this.markerDeltaX, this.imgCenterPx[1] + this.markerDeltaY]; if (De(e, this.imgCenterPx)) return n(this, Pr); { let r = Rs.ll(e, this.zoom); return [Sn(r[0], 6), Sn(r[1], 6)] } } set coordinate(e) { p(this, Pr, e), this.imgCenterPx = this.imgCenterAdjustedPx = Rs.px(e, this.zoom) } get imgCenterOffset() { return { x: this.imgCenterPx[0] - this.imgCenterAdjustedPx[0], y: this.imgCenterPx[1] - this.imgCenterAdjustedPx[1] } } }; Br = new WeakMap, qi = new WeakMap, qe = new WeakMap, Or = new WeakMap, Pr = new WeakMap, Ki = new WeakMap, Hr = new WeakMap, _r = new WeakMap, Zi = new WeakMap, Fr = new WeakMap, Nr = new WeakMap, Ke = new WeakMap, Qi = new WeakMap, Dr = new WeakMap; var Ps = '<svg width="88" height="23" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill-rule="evenodd"><defs><path id="g" d="M11.5 2.25a9.25 9.25 0 1 1 0 18.5 9.25 9.25 0 0 1 0-18.5zM7 15.98c-.05-.33-.83-5.8 2.23-8.87a4.4 4.4 0 0 1 3.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39a4.4 4.4 0 0 1-1.28 3.13C12.72 16.93 7 16 7 16v-.02zm8.3-5.48-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z"/><path id="b" d="M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19A3.77 3.77 0 0 1 50.86 15v3.77c0 .13-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01.01-.01c.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V15a3.7 3.7 0 0 1-2.73 1.19c-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.38-.19a4.24 4.24 0 0 0-4.16 3.29 4.07 4.07 0 0 0 0 1.77 4.23 4.23 0 0 0 4.17 3.3 4.22 4.22 0 0 0 4.26-4.19 4.2 4.2 0 0 0-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18a4 4 0 0 1 3.84 3.28c.13.59.13 1.2 0 1.8a4 4 0 0 1-3.84 3.29A3.77 3.77 0 0 1 60.86 15v.77c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4a.23.23 0 0 1-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55a2.73 2.73 0 0 1 2.44-1.56c1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.62 0h-1.61a.27.27 0 0 1-.12-.03c-.1-.06-.13-.19-.06-.28l2.43-3.71-2.4-3.65a.21.21 0 0 1-.02-.12.2.2 0 0 1 .2-.21h1.61c.13 0 .24.06.3.17L82 10.54l1.4-2.37a.34.34 0 0 1 .3-.17h1.6l.12.03c.1.06.13.19.06.28l-2.37 3.65 2.43 3.7.01.13a.2.2 0 0 1-.2.21h-1.61a.33.33 0 0 1-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 0 1-.3.17zm-7.12-1.49A2.47 2.47 0 0 1 70.7 12a2.47 2.47 0 0 1 2.42-2.52 2.47 2.47 0 0 1 2.42 2.51 2.48 2.48 0 0 1-2.42 2.52zm-19.87 0a2.48 2.48 0 0 1-2.42-2.48v-.07a2.47 2.47 0 0 1 2.4-2.49 2.47 2.47 0 0 1 2.41 2.51 2.47 2.47 0 0 1-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51a2.47 2.47 0 0 1 2.4-2.52 2.46 2.46 0 0 1 2.41 2.48l.02.08zm18.12 2.47a2.47 2.47 0 0 1-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51a2.47 2.47 0 0 1-2.42 2.51z"/></defs><mask id="c"><rect width="100%" height="100%" fill="#fff"/><use xlink:href="#g"/><use xlink:href="#b"/></mask><g opacity=".3" stroke="#000" stroke-width="3"><circle mask="url(#c)" cx="11.5" cy="11.5" r="9.25"/><use xlink:href="#b" mask="url(#c)"/></g><g opacity=".9" fill="#fff"><use xlink:href="#g"/><use xlink:href="#b"/></g></svg>'; var Hs = 16, Cl = j(`
<template>
  <div class="MapboxAddressMinimap" aria-hidden="true">
    <div class="MinimapImageContainer">
      <img class="MinimapImage" draggable="false"></img>
      <div class="MinimapInnerFrame">
        <div class="MinimapMarker"></div>
        <div class="MinimapAttribution">
          <div class="MinimapAttributionLogo">
            <a target="_blank" rel="noopener nofollow" href="https://www.mapbox.com/" aria-label="Mapbox logo">
              ${Ps}
            </a>
          </div>
          <div class="MinimapAttributionText">
            <a target="_blank" href='https://www.mapbox.com/about/maps/'>\xA9 Mapbox</a><a target="_blank" href='http://www.openstreetmap.org/copyright'>\xA9 OpenStreetMap</a>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
`), kl = j(`
<template>
  <button type="button" class="MinimapStyleToggle"></button>
</template>
`), Il = j(`
<template>
  <div class="MinimapFooter">Adjust the marker on the map if it doesn't precisely match your location. This helps improve address data quality.</div>
</template>
`), Wn = "Adjust pin", Xn = "Save", qn = "Cancel", Rl = j(`
<template>
  <div class="MinimapEditButtons">
    <div class="Button ButtonPrimary MinimapButtonAdjust">${Wn}</div>
    <div class="Button ButtonPrimary MinimapButtonSave" aria-hidden="true">${Xn}</div>
    <div class="Button MinimapButtonCancel" aria-hidden="true">${qn}</div>
  </div>
</template>
`), jr, Qe, xt, ye, Pe, ae, le, C, N, $r, Ur, zr, Je, Gr, Vr, Yr, Wr, Xr, qr, At, Kr, Zr, Qr, Jr, Ji, en, ei, Et, St, ti, ri, tn, ii, rn, Mt = class extends W { constructor() { super(...arguments); d(this, jr, !1); this.keepMarkerCentered = !1; this.markerAnchor = "bottom"; d(this, Qe, !1); d(this, xt, !1); d(this, ye, void 0); d(this, Pe, ""); d(this, ae, void 0); d(this, le, void 0); d(this, C, void 0); d(this, N, void 0); d(this, $r, void 0); d(this, Ur, {}); d(this, zr, !1); d(this, Je, "default"); d(this, Gr, void 0); d(this, Vr, void 0); d(this, Yr, void 0); d(this, Wr, ["mapbox", "streets-v11"]); d(this, Xr, void 0); d(this, qr, void 0); d(this, At, () => { let { ImageContainer: e, ButtonAdjust: r, ButtonSave: i, ButtonCancel: o } = n(this, C); n(this, Qe) ? (e.classList.add(`${this.dataset.seed}--draggable`), n(this, N).isActive = !0, r.setAttribute("aria-hidden", "true"), i.removeAttribute("aria-hidden"), o.removeAttribute("aria-hidden")) : (e.classList.remove(`${this.dataset.seed}--draggable`), n(this, N).isActive = !1, r.removeAttribute("aria-hidden"), i.setAttribute("aria-hidden", "true"), o.setAttribute("aria-hidden", "true")) }); d(this, Kr, () => { p(this, Qe, !0), n(this, At).call(this) }); d(this, Zr, () => { if (this.feature.properties.full_address && !De(this.feature.geometry.coordinates, n(this, N).coordinate)) { let [e, r] = n(this, N).coordinate; Gi(this.accessToken, { originalCoordinate: this.feature.geometry.coordinates, originalAddress: this.feature.properties.full_address, changes: { location: { longitude: e, latitude: r } } }) } this.onSaveMarkerLocation && this.onSaveMarkerLocation(n(this, N).coordinate), p(this, Qe, !1), n(this, At).call(this) }); d(this, Qr, () => { n(this, N).reCenter(), p(this, Qe, !1), n(this, At).call(this) }); d(this, Jr, () => { this.mapStyleMode = this.mapStyleMode === "default" ? "satellite" : "default" }); d(this, Ji, () => { n(this, xt) || n(this, N).reCenter(), p(this, xt, !0), n(this, N) && n(this, N).handleMinimapResize() }); d(this, en, () => { p(this, xt, !1) }); d(this, ei, e => { if (n(this, ae) === 0 || n(this, le) === 0) return ""; let [r, i] = this.defaultMapStyle, o = Ei(r, i), s = this.mapStyleMode === "default" ? o : Ao, l = Eo + R.autofillSessionToken.toString(), a = s + _.convert(e).toArray().join(",") + "," + Hs + ",0/" + Math.min(n(this, ae) * 2, Ze) + "x" + Math.min(n(this, le) * 2, Ze) + "?access_token=" + this.accessToken + "&attribution=false&logo=false"; return R.autofillSessionEnabled && (a += `&sku=${l}`), a }); d(this, Et, () => { if (n(this, ye)) { let e = n(this, ye).geometry.coordinates; p(this, Pe, n(this, ei).call(this, e)); let { Image: r } = n(this, C); r.src = n(this, Pe) } }); d(this, St, e => `url("${Po(e === "default" ? "styleToggleDefault" : "styleToggleSatellite", this.theme)}")`); d(this, ti, () => { let { MapboxAddressMinimap: e, ImageContainer: r, Image: i } = n(this, C), { width: o, height: s } = gi(this.container), [l, a] = [n(this, ae), n(this, le)]; p(this, ae, Math.min(o, Ze)), p(this, le, Math.min(s, Ze)), e.style.setProperty("width", `${n(this, ae)}px`), e.style.setProperty("height", `${n(this, le)}px`), r.style.setProperty("height", `${n(this, le)}px`), r.style.setProperty("width", `${n(this, ae)}px`); let [c, u] = [i.width, i.height]; n(this, ae) > l && n(this, ae) > c / 2 && c < Ze || n(this, le) > a && n(this, le) > u / 2 && u < Ze ? n(this, Et).call(this) : n(this, N) && n(this, N).handleMinimapResize() }); d(this, ri, () => { if (this.querySelector(".MinimapFooter")) return; let r = this.prepareTemplate(Il), i = this.querySelector(".MapboxAddressMinimap"); if (!i || (i.appendChild(r), this.querySelector(".MinimapEditButtons"))) return; let s = this.prepareTemplate(Rl); this.querySelector(".MinimapInnerFrame").appendChild(s), p(this, C, z(x({}, n(this, C)), { EditButtons: this.querySelector(".MinimapEditButtons"), ButtonAdjust: this.querySelector(".MinimapButtonAdjust"), ButtonSave: this.querySelector(".MinimapButtonSave"), ButtonCancel: this.querySelector(".MinimapButtonCancel") })); let { ButtonAdjust: a, ButtonSave: c, ButtonCancel: u } = n(this, C); a.addEventListener("click", n(this, Kr)), c.addEventListener("click", n(this, Zr)), u.addEventListener("click", n(this, Qr)) }); d(this, tn, () => { if (!n(this, C)) return; let { EditButtons: e, ButtonAdjust: r, ButtonSave: i, ButtonCancel: o } = n(this, C), s = this.querySelector(".MinimapFooter"); s == null || s.remove(), e == null || e.remove(), r && (r.remove(), r.removeEventListener("click", n(this, Kr))), i && (i.remove(), i.removeEventListener("click", n(this, Zr))), o && (o.remove(), o.removeEventListener("click", n(this, Qr))), delete n(this, C).EditButtons, delete n(this, C).ButtonAdjust, delete n(this, C).ButtonSave, delete n(this, C).ButtonCancel }); d(this, ii, () => { if (this.querySelector(".MinimapStyleToggle")) return; let r = this.prepareTemplate(kl), i = this.querySelector(".MinimapInnerFrame"); !i || (i.appendChild(r), n(this, C).MapStyleToggle = r, r.addEventListener("click", n(this, Jr)), r.style.backgroundImage = n(this, St).call(this, this.mapStyleMode === "default" ? "satellite" : "default"), r.setAttribute("title", `Switch to ${this.mapStyleMode === "default" ? "Satellite" : "Default"}`)) }); d(this, rn, () => { if (!n(this, C)) return; let { MapStyleToggle: e } = n(this, C); !e || (e.remove(), e.removeEventListener("click", n(this, Jr)), delete n(this, C).MapStyleToggle) }) } get canAdjustMarker() { return n(this, jr) } set canAdjustMarker(e) { p(this, jr, e), e ? n(this, ri).call(this) : n(this, tn).call(this) } get accessToken() { return n(this, $r) || R.accessToken } set accessToken(e) { p(this, $r, e) } get feature() { return n(this, ye) } set feature(e) { p(this, ye, e), e ? this.show() : this.hide() } get template() { return Cl } get templateStyle() { return te } get templateUserStyle() { return $(".MapboxAddressMinimap", this.theme) } get satelliteToggle() { return n(this, zr) } set satelliteToggle(e) { p(this, zr, e), e ? n(this, ii).call(this) : n(this, rn).call(this) } get theme() { return n(this, Ur) } set theme(e) { if (p(this, Ur, e), !n(this, C) || !e) return; this.updateTemplateUserStyle($(".MapboxAddressMinimap", e)); let { Marker: r, MapStyleToggle: i } = n(this, C); r.innerHTML = V("marker", e), i && (i.style.backgroundImage = n(this, St).call(this, this.mapStyleMode === "default" ? "satellite" : "default")) } get adjustBtnText() { return n(this, Gr) || Wn } set adjustBtnText(e) { p(this, Gr, e); let r = this.querySelector(".MinimapButtonAdjust"); r.textContent = e || Wn } get saveBtnText() { return n(this, Vr) || Xn } set saveBtnText(e) { p(this, Vr, e); let r = this.querySelector(".MinimapButtonSave"); r.textContent = e || Xn } get cancelBtnText() { return n(this, Yr) || qn } set cancelBtnText(e) { p(this, Yr, e); let r = this.querySelector(".MinimapButtonCancel"); r.textContent = e || qn } get mapStyleMode() { return n(this, Je) } set mapStyleMode(e) { let r = n(this, Je); if (r === e || (p(this, Je, e), !n(this, C))) return; let { MapStyleToggle: i } = n(this, C); !i || (i.style.backgroundImage = n(this, St).call(this, r), i.setAttribute("title", `Switch to ${r === "satellite" ? "Satellite" : "Default"}`), n(this, Et).call(this)) } get defaultMapStyle() { return n(this, Wr) } set defaultMapStyle(e) { p(this, Wr, e), n(this, Et).call(this) } get footer() { return n(this, Xr) } set footer(e) { p(this, Xr, e); let r = this.querySelector(".MinimapFooter"); r && (typeof e == "string" ? (r.textContent = e, r.removeAttribute("aria-hidden")) : e ? r.removeAttribute("aria-hidden") : r.setAttribute("aria-hidden", "true")) } get container() { return n(this, qr) } set container(e) { e && (e.style.position = "relative", p(this, qr, e)) } show() { if (!n(this, ye)) return; let e = n(this, ye).geometry.coordinates; n(this, N).coordinate = e, p(this, Pe, n(this, ei).call(this, e)); let { MapboxAddressMinimap: r, Image: i } = n(this, C); i.src = n(this, Pe), r.removeAttribute("aria-hidden") } hide() { let { MapboxAddressMinimap: e } = n(this, C); e.setAttribute("aria-hidden", "true") } connectedCallback() { super.connectedCallback(), p(this, C, J(this, { MapboxAddressMinimap: ".MapboxAddressMinimap", ImageContainer: ".MinimapImageContainer", Image: ".MinimapImage", Marker: ".MinimapMarker", MapStyleToggle: ".MinimapStyleToggle", EditButtons: ".MinimapEditButtons", ButtonAdjust: ".MinimapButtonAdjust", ButtonSave: ".MinimapButtonSave", ButtonCancel: ".MinimapButtonCancel" })), this.mapStyleMode = n(this, Je), this.theme = x({}, this.theme), this.canAdjustMarker && n(this, ri).call(this), this.satelliteToggle && n(this, ii).call(this), this.container = this.parentElement, new ResizeObserver(n(this, ti)).observe(this.container), n(this, ti).call(this); let { MapboxAddressMinimap: r, ImageContainer: i, Image: o, Marker: s } = n(this, C); p(this, N, new Yn(i, o, s, this.keepMarkerCentered, Hs, this.markerAnchor)), n(this, N).reCenter(), o.onload = n(this, Ji), o.onerror = n(this, en), o.src = n(this, Pe), n(this, ye) ? r.removeAttribute("aria-hidden") : r.setAttribute("aria-hidden", "true") } attributeChangedCallback(e, r, i) { if (e === "access-token") this.accessToken = i; else if (e === "can-adjust-marker") this.canAdjustMarker = i === "true"; else if (e === "keep-marker-centered") this.keepMarkerCentered = i === "true"; else if (e === "marker-anchor") { let o = i; this.markerAnchor = o, n(this, N) && (n(this, N).anchor = o) } else e === "satellite-toggle" && (this.satelliteToggle = i === "true") } }; jr = new WeakMap, Qe = new WeakMap, xt = new WeakMap, ye = new WeakMap, Pe = new WeakMap, ae = new WeakMap, le = new WeakMap, C = new WeakMap, N = new WeakMap, $r = new WeakMap, Ur = new WeakMap, zr = new WeakMap, Je = new WeakMap, Gr = new WeakMap, Vr = new WeakMap, Yr = new WeakMap, Wr = new WeakMap, Xr = new WeakMap, qr = new WeakMap, At = new WeakMap, Kr = new WeakMap, Zr = new WeakMap, Qr = new WeakMap, Jr = new WeakMap, Ji = new WeakMap, en = new WeakMap, ei = new WeakMap, Et = new WeakMap, St = new WeakMap, ti = new WeakMap, ri = new WeakMap, tn = new WeakMap, ii = new WeakMap, rn = new WeakMap, Mt.observedAttributes = ["access-token", "can-adjust-marker", "keep-marker-centered", "marker-anchor", "satellite-toggle"]; window.MapboxAddressMinimap = Mt; window.customElements.get("mapbox-address-minimap") || customElements.define("mapbox-address-minimap", Mt); var U, we, q, Le, ni, oi, si, ai, li, ci, Tt, _s = class { constructor(e, r, i) { d(this, U, void 0); d(this, we, void 0); d(this, q, void 0); this.options = {}; this.retrieveFeature = null; this.listbox = new Se; d(this, Le, void 0); d(this, ni, e => { let r = e.detail, i = n(this, we).browserAutofillEnabled === !0 && (r == null ? void 0 : r.length) <= 2; if (re(n(this, U), n(this, Le), i), (r == null ? void 0 : r.length) <= 2) { this.listbox.handleSuggest(null); return } n(this, q).suggest(r, this.options) }); d(this, oi, e => { let r = e.detail; e.detail.accuracy !== "street" ? (re(n(this, U), n(this, Le), !0), n(this, q).retrieve(r, this.options)) : Fi(n(this, U), n(this, Le), r) }); d(this, si, () => { re(n(this, U), n(this, Le), !0), n(this, q).abort() }); d(this, ai, () => { var r; let e = n(this, we).browserAutofillEnabled === !0 && ((r = n(this, U).value) == null ? void 0 : r.length) <= 2; re(n(this, U), n(this, Le), e) }); d(this, li, e => { let r = (e == null ? void 0 : e.suggestions) ? _i(e.suggestions) : null; this.listbox.handleSuggest(r); let i = new M("suggest", e); Object.defineProperty(i, "target", { value: n(this, U) }), n(this, we).fire("suggest", i) }); d(this, ci, e => { this.listbox.handleError(); let r = new M("suggesterror", e); Object.defineProperty(r, "target", { value: n(this, U) }), n(this, we).fire("suggesterror", r) }); d(this, Tt, e => { var o; let r = new M("retrieve", e); if (Object.defineProperty(r, "target", { value: n(this, U) }), n(this, we).fire("retrieve", r), this.retrieveFeature = (o = e.features) == null ? void 0 : o[0], !n(this, U)) return; let i = e; !i || !i.features || !i.features.length || Zt(i.features[0], n(this, U)) }); p(this, U, r), p(this, we, e), p(this, q, new it(i)), n(this, q).sessionToken = R.autofillSessionToken, this.listbox.input = n(this, U), this.listbox.autofillHost = this, this.listbox.searchService = 0, this.listbox.addEventListener("input", n(this, ni)), this.listbox.addEventListener("select", n(this, oi)), this.listbox.addEventListener("blur", n(this, si)), this.listbox.addEventListener("focus", n(this, ai)), n(this, q).addEventListener("suggest", n(this, li)), n(this, q).addEventListener("suggesterror", n(this, ci)), n(this, q).addEventListener("retrieve", n(this, Tt)), document.body.appendChild(this.listbox), r && (r.insertAdjacentElement("beforebegin", at(this.listbox.dataSeed)), Oi(r), p(this, Le, r.autocomplete)) } get input() { return n(this, U) } remove() { this.listbox.remove(), this.listbox.removeEventListener("input", n(this, ni)), this.listbox.removeEventListener("select", n(this, oi)), this.listbox.removeEventListener("blur", n(this, si)), this.listbox.removeEventListener("focus", n(this, ai)), n(this, q).removeEventListener("suggest", n(this, li)), n(this, q).removeEventListener("suggesterror", n(this, ci)), n(this, q).removeEventListener("retrieve", n(this, Tt)) } simulateRetrieve(e) { let r = n(this, U); r && (r.dataset.mapboxSuccess = "true"), this.listbox.hideResults(); let i = { type: "FeatureCollection", features: [e], url: "" }; n(this, Tt).call(this, i) } }; U = new WeakMap, we = new WeakMap, q = new WeakMap, Le = new WeakMap, ni = new WeakMap, oi = new WeakMap, si = new WeakMap, ai = new WeakMap, li = new WeakMap, ci = new WeakMap, Tt = new WeakMap; var wt, Lt, Ct, di, ui, hi, pi, fi, Fs = class extends xn { constructor({ accessToken: e, options: r, theme: i, popoverOptions: o, confirmOnBrowserAutofill: s, browserAutofillEnabled: l }) { super(); this.instances = []; d(this, wt, void 0); d(this, Lt, new Ht); d(this, Ct, void 0); d(this, di, void 0); d(this, ui, void 0); this.confirmOnBrowserAutofill = !1; this.browserAutofillEnabled = !1; d(this, hi, () => { De(Xt(), n(this, wt)) || this.update() }); d(this, pi, new MutationObserver(n(this, hi))); d(this, fi, e => F(this, null, function* () { this.instances.forEach(r => r.listbox.blur()); for (let r of this.instances) { let i = r.listbox.input; yield zi(i, e, this.confirmOnBrowserAutofill, this.accessToken) } })); Yi(), window.addEventListener("browserautofill", n(this, fi)), R.autofillSessionEnabled = !0, this.accessToken = e || R.accessToken, r && (this.options = r), i && (this.theme = i), o && (this.popoverOptions = o), s && (this.confirmOnBrowserAutofill = s), l && (this.browserAutofillEnabled = l), this.update() } get accessToken() { return n(this, Lt).accessToken } set accessToken(e) { n(this, Lt).accessToken = e } get options() { return n(this, Ct) } set options(e) { p(this, Ct, x(x({}, n(this, Ct)), e)), this.instances.forEach(r => { r.options = x(x({}, r.options), e) }) } get theme() { return n(this, di) } set theme(e) { p(this, di, e), this.instances.forEach(r => { r.listbox.theme = e }) } get popoverOptions() { return n(this, ui) } set popoverOptions(e) { p(this, ui, e), this.instances.forEach(r => { r.listbox.popoverOptions = e }) } update() { this.instances.forEach(e => { e.remove() }), p(this, wt, Xt()), this.instances = [], n(this, wt).forEach(e => { let r = new _s(this, e, n(this, Lt)); r.options = this.options, r.listbox.theme = this.theme, r.listbox.popoverOptions = this.popoverOptions, this.instances.push(r) }) } observe() { n(this, pi).observe(document, { subtree: !0, childList: !0 }), n(this, hi).call(this) } unobserve() { n(this, pi).disconnect() } remove() { this.instances.forEach(e => { e.remove() }), this.unobserve(), window.removeEventListener("browserautofill", n(this, fi)) } }; wt = new WeakMap, Lt = new WeakMap, Ct = new WeakMap, di = new WeakMap, ui = new WeakMap, hi = new WeakMap, pi = new WeakMap, fi = new WeakMap; function Ns(t) { return new Fs(t) } return Ws(Bl);
})();
/*!
* focus-trap 6.7.3
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
/*!
* tabbable 5.2.1
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
//# sourceMappingURL=mapboxsearch.js.map